{"meta":{"title":"Kx's Blog","subtitle":"","description":"Kx 的个人博客","author":"Kx's Blog","url":"http://onekx.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-04-02T16:16:59.000Z","updated":"2020-04-26T13:50:13.401Z","comments":true,"path":"about/index.html","permalink":"http://onekx.github.io/about/index.html","excerpt":"","text":"关于博客为了整理笔记，记录以往遇到过的问题。 关于我前端爱好者。 联系邮箱： kongxinone@163.com"},{"title":"tags","date":"2020-04-02T16:17:26.000Z","updated":"2020-04-02T16:20:18.823Z","comments":true,"path":"tags/index.html","permalink":"http://onekx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"react-navigation 的配置","slug":"config-navigation","date":"2020-05-03T08:56:53.000Z","updated":"2020-05-03T09:03:04.798Z","comments":true,"path":"post/config-navigation/","link":"","permalink":"http://onekx.github.io/post/config-navigation/","excerpt":"","text":"一定要查看官方的英文文档，其他中文文档有滞后，版本过低 1. 安装基本模块npm i @react-navigation/native 2. 安装所需要的依赖项库npm i react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view 3. 安装三种导航模式npm i @react-navigation/stack @react-navigation/bottom-tabs @react-navigation/drawer StackNavigator: 栈导航 TabNavigator: 标签导航 DrawerNavigator: 抽屉导航","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://onekx.github.io/tags/React-Native/"}]},{"title":"用 json-server 模拟服务器","slug":"json-server","date":"2020-04-25T11:41:33.000Z","updated":"2020-04-25T11:57:55.601Z","comments":true,"path":"post/json-server/","link":"","permalink":"http://onekx.github.io/post/json-server/","excerpt":"","text":"利用 json-server 模拟服务器，可以进行数据的请求。 1. 全局安装 json-servernpm install -g json-server 2. 在项目目录下创建 server 文件夹和 db.json 文件，如下： 3. 进入 server 目录下，启动服务cd server json-server db.json 默认是 3000 端口，可以在命令中加 --port 参数改变端口,如json-server --port 5000 db.json将在 5000 端口启动服务。 之后就可以请求 http://localhost:3000/result 来获取数据。","categories":[],"tags":[{"name":"json-server","slug":"json-server","permalink":"http://onekx.github.io/tags/json-server/"}]},{"title":"修改 apk 相关信息","slug":"change-apk","date":"2020-04-23T05:30:24.000Z","updated":"2020-04-23T06:18:50.910Z","comments":true,"path":"post/change-apk/","link":"","permalink":"http://onekx.github.io/post/change-apk/","excerpt":"","text":"修改 app 名字打开项目下的 ./android/app/src/main/res/values/strings.xml 文件 ***** &lt/string>&lt/resources> 将其中的 ***** 替换为自己 app 的名字 修改 app 图标首先制作不同分辨率下的图标，生成以下目录（推荐网站：图标工厂 ）： 打开项目下的 ./android/app/src/main/res 文件夹，用自己制作的文件替换掉 res 目录下的文件 减小 apk 文件的大小打开项目下 ./android/app/build.gradle 文件，将下面两个 false 改为 true def enableSeparateBuildPerCPUArchitecture = false //更改为 truedef enableProguardInReleaseBuilds = false //更改为 true enableSeparateBuildPerCPUArchitecture 会生成多个适应不同 CPU 架构的包 如果想额外生成一个适应所有 CPU 架构的 apk ，则将文件中的 universalApk false 修改为 universalApk true enableProguardInReleaseBuilds 会移除掉 React Native Java（和它的依赖库中）中没有被使用到的部分，最终减少 apk 的大小。","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://onekx.github.io/tags/React-Native/"}]},{"title":"报错：'app:installDebug'","slug":"install_debug","date":"2020-04-23T03:47:16.000Z","updated":"2020-04-23T05:41:15.405Z","comments":true,"path":"post/install_debug/","link":"","permalink":"http://onekx.github.io/post/install_debug/","excerpt":"","text":"当我在更新项目后，尝试重新打包 apk 时，报了下面的错误： * What went wrong:Execution failed for task ':app:installDebug'.> com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package com.rndemo signatures do not match previously installed version; ignoring! 原因是设备上存在的旧版本与此时的新版本冲突了。解决办法：删除设备上的旧版本 App 或者清除虚拟设备的数据，然后重新打包","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://onekx.github.io/tags/React-Native/"},{"name":"Errors","slug":"Errors","permalink":"http://onekx.github.io/tags/Errors/"}]},{"title":"react-native 打包 apk 文件","slug":"apk","date":"2020-04-22T11:10:46.000Z","updated":"2020-04-22T12:40:26.334Z","comments":true,"path":"post/apk/","link":"","permalink":"http://onekx.github.io/post/apk/","excerpt":"","text":"1. 生成签名密钥：打开 CMD ,输入下面一行命令: keytool -genkeypair -v -keystore onekx.keystore -alias kx -keyalg RSA -keysize 2048 -validity 10000 onekx.keystore 是待会儿会生成的密钥文件 -alias后的别名 kx 后面应用签名时会使用 -validity后的 10000 表示此密钥有效期 10000 天 随后会要求输入以下问题：(必须将以下问题的回答都详细记录备份) 输入密钥库口令 再次输入新口令 名字与姓氏 组织单位名称 组织名称 所在城市区域名称 所在省/市/自治区名称 国家/地区代码 是否正确？(此时在命令行输入: 是) 然后会生成一个 onekx.keystore 的文件，路径: C:\\用户\\*** 2. 设置 gradle 变量: 将 onekx.keystore 文件复制到项目的 android/app 目录下 打开 ./android/app/gradle/gradle.properties 文件，在文件中加入如下代码，并把其中的*****替换为相应密码： MYAPP_RELEASE_STORE_FILE=onekx.keystoreMYAPP_RELEASE_KEY_ALIAS=kxMYAPP_RELEASE_STORE_PASSWORD=*****MYAPP_RELEASE_KEY_PASSWORD=***** 3. 添加签名到应用的gradle配置中：打开 ./android/app/build.gradle 文件,添加如下代码： ...android { ... defaultConfig { ... } signingConfigs { release { if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) { storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD } } } buildTypes { release { ... signingConfig signingConfigs.release } }}... 4. 生成 release 版本的 APK 包：打开终端，进入项目下的 ./android 目录，运行如下命令： ./gradlew assembleRelease 此时会生成一个 app-release.apk 文件，就是软件的安装包，位于：./android/app/build/outputs/apk/release 目录下，打包完成。","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://onekx.github.io/tags/React-Native/"}]},{"title":"React 生命周期","slug":"life_cycle","date":"2020-04-07T07:54:09.000Z","updated":"2020-04-13T13:17:09.385Z","comments":true,"path":"post/life_cycle/","link":"","permalink":"http://onekx.github.io/post/life_cycle/","excerpt":"","text":"React 生命周期分为三个阶段： 挂载阶段、 更新阶段、 卸载阶段 挂载阶段：生命周期函数调用顺序： constructor(props){ super(props)}static getDerivedStateFromProps(props, state)render()componentDidMount() constructor组件构造函数，最先被执行，如果没有定义，会被默认生成。要在构造函数中使用 this ,就必须在构造函数第一行执行 super(props)。 构造函数作用： 初始化 state 给自定义方法绑定 this constructor(props){ super(props) this.state = { name: 'kx' } this.handleClick = this.handleClick.bind(this);} bind(this) 的作用就是保证该自定义方法的 this 始终是指向该组件，可以使用箭头函数代替它。 getDerivedStateFromProps 该方法不常用，只有当 state 的值任何时候都取决于 props 时才会使用 静态方法，函数内部不能使用 this 接受两个参数，props 和当前的 state 返回一个对象更新 state 或者 返回 null 不更新 使用该方法的时候需要初始化 state,否则会报错 state = { name: 'kx'}static getDerivedStateFromProps(props, state) { if (props.name !== state.name) { return { name: props.name } } return null} render 组件中必须包含 render() 方法。 render 是纯函数，只返回需要渲染的东西，不能在其中处理业务逻辑和数据请求。 return 中必须包含一个 UI 元素。 componentDidMount在组件挂载完成后调用，全局只调用一次，此时可以获取到 DOM 节点并进行操作。通常在该方法内进行异步请求，并可以在异步请求中进行 setState 操作。 更新阶段生命周期函数调用顺序： getDerivedStateFromProps(props, state)shouldComponentUpdate(nextProps, nextState)render()getSnapshotBeforeUpdate(prevProps, prevState)componentDidUpdate(prevProps, prevState, snapshot) getDerivedStateFromProps与挂载阶段一样 shouldComponentUpdate在组件挂载完成后，每次使用 setState 后都会调用该方法。接受两个参数，nextProps 和 nextState，表示新的 props 和 state。返回的是一个布尔值，表示是否需要重新渲染，默认返回 true shouldComponentUpdate(nextProps, nextState) { return nextState.name !== this.state.name} render当收到 shouldComponentUpdate 返回的 true 之后，render 会重新渲染 getSnapshotBeforeUpdate传入两个参数，prevProps 表示更新前的 props，prevState 表示更新前的 state必须有一个返回值，返回值将作为第三个参数传给 componentDidUpdate，如果没有可返回的值，则必须返回 null该方法必须和 componentDidUpdate 一起使用 这个函数的作用是在真实 DOM 更新（componentDidUpdate）前，获取一些需要的信息（类似快照功能），然后作为参数传给 componentDidUpdate。例如:在getSnapShotBeforeUpdate中获取滚动位置，然后作为参数传给componentDidUpdate，就可以直接在渲染真实的 DOM 时就滚动到需要的位置。 componentDidUpdate接受三个参数，之前的 props，之前的 state 以及 getSnapshotBeforeUpdate 返回的值在组件每次更新后都会调用此方法，可以在这个方法内操作 DOM，向服务器发送请求在该方法内使用 setState 时，需要使用 if 语句进行判断，否则将陷入死循环 卸载阶段componentWillUnmount卸载阶段只有这一个生命周期函数，每当React使用完一个组件，这个组件必须从 DOM 中卸载后被销毁，此时 componentWillUnmout 会被执行。可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://onekx.github.io/tags/React/"}]},{"title":"实现页面上方进度条","slug":"progress_line","date":"2020-04-05T02:43:47.000Z","updated":"2020-04-05T04:52:42.911Z","comments":true,"path":"post/progress_line/","link":"","permalink":"http://onekx.github.io/post/progress_line/","excerpt":"","text":"实现位于页面上方，跟随视图滚动而不断变化的进度条。 1. 首先在页面中添加： &lt;/div>&lt;/div> 2. 设置样式：#progress { top: 0 position: fixed width: 100% height: 0.2rem text-align: left z-index: 9999}#progress .line { width: 0% height: 0.2rem background-color: #0099ff} 3. 编写 JS 代码：$(window).scroll(function() { var pageHeight = document.documentElement.scrollHeight || document.body.scrollHeight // 页面总高度 var windowHeight = document.documentElement.clientHeight || document.body.clientHeight // 浏览器视口高度 var scrollAvail = pageHeight - windowHeight // 可滚动的高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop // 获取滚动条的高度 var ratio = (scrollTop / scrollAvail) * 100 + '%' $('#progress > .line').css('width', ratio)})","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://onekx.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://onekx.github.io/tags/CSS/"}]},{"title":"ESLint 的配置","slug":"deploy_eslint","date":"2020-04-04T07:37:39.000Z","updated":"2020-04-13T13:16:59.818Z","comments":true,"path":"post/deploy_eslint/","link":"","permalink":"http://onekx.github.io/post/deploy_eslint/","excerpt":"","text":"1. 安装所需要的包 npm install --save-dev husky lint-staged eslint 2. 如果配置文件里有使用到airbnb，通过以下命令来安装eslint-config-airbnb及它的相关依赖 npm install --save-dev eslint-config-airbnb npm install --save eslint-plugin-import eslint-plugin-react eslint-plugin-jsx-a11y 3. 设置一个配置文件 ./node_modules/.bin/eslint --init 4. 在根目录下 .eslintrc 文件中配置自己的rules，以下是我使用的配置： { \"env\": { \"browser\": true, \"es6\": true, \"node\": true }, \"extends\": [ \"airbnb\" ], \"parser\": \"babel-eslint\", \"globals\": { \"Atomics\": \"readonly\", \"SharedArrayBuffer\": \"readonly\" }, \"parserOptions\": { \"ecmaFeatures\": { \"jsx\": true, \"legacyDecorators\": true }, \"ecmaVersion\": 2018, \"sourceType\": \"module\" }, \"plugins\": [ \"react\" ], \"rules\": { \"indent\": [\"error\", 4, { \"SwitchCase\": 1,\"flatTernaryExpressions\": true }], \"max-len\": [\"error\", { \"code\": 120, \"ignoreUrls\": true }], \"react/jsx-indent\": [\"error\", 4], \"react/jsx-indent-props\": [\"error\", 4], \"react/jsx-filename-extension\": [\"warn\", { \"extensions\": [\".js\",\".jsx\"] }], \"react/prop-types\": \"off\", \"no-unused-expressions\": [\"error\", { \"allowShortCircuit\": true }], \"no-underscore-dangle\": 0, \"no-console\": [\"error\", { \"allow\": [\"log\"] }], \"react/jsx-props-no-spreading\": [\"error\", { \"custom\": \"ignore\" }], \"import/no-cycle\": 0, \"radix\": [\"error\", \"as-needed\"] } } 5. 在 package.json 文件中配置husky和lint-staged，用于提交前的检测，示例： \"husky\": { \"hooks\": { \"pre-commit\": \"lint-staged\" } }, \"lint-staged\": { \"*.js\": [ \"eslint --fix\", \"git add\" ] }","categories":[],"tags":[{"name":"ESLint","slug":"ESLint","permalink":"http://onekx.github.io/tags/ESLint/"}]},{"title":"对 Promise 的理解","slug":"about_promise","date":"2020-04-02T10:47:31.000Z","updated":"2020-04-05T03:52:28.651Z","comments":true,"path":"post/about_promise/","link":"","permalink":"http://onekx.github.io/post/about_promise/","excerpt":"","text":"以下是自己对Promise的简单理解 Promise的作用：js中使用回调函数进行事件处理，如果嵌套多层回调函数，将会陷入 回调地狱，使代码难以理解以及维护，例如： method1(function(err, result) { if (err) { throw err; } method2(function(err, result) { if (err) { throw err; } method3(function(err, result) { if (err) { throw err; } method4(function(err, result) { if (err) { throw err; } method5(result); }); }); });}); Promise就是解决以上这种问题的异步编程方案。 Promise的构造：直接在控制台中将Promise打印出来: 可以看到 Promise 包含了 resolve, reject, all, race等方法，原型上有 then, catch, finally等方法，所以当 new 一个 Promise 对象时一定包含以上方法。 Promise的三种状态： Pending（进行中），Fulfilled（已完成），Rejected（已拒绝） 当 Promise 被声明时，即处于 “Pending” 状态。接着状态的变更只能是 “Pending => Fufilled” （Fufilled对应的就是resolv方法）和 “Pending => Rejected”两种，且状态的变更是单向不可逆的。 var promise1 = new Promise((resolve, reject) => {});// Pending状态var promise2 = new Promise((resolve, reject) => resolve());// Fulfilled状态var promise3 = new Promise((resolve, reject) => reject());// Rejected状态 then 、 catch 和 finally 的用法：then：then 为返回成功时调用的方法。then 有两个参数，第一个参数是 resolved 状态的回调函数，第二个参数 (可选) 是 rejected 状态的回调函数。 建议 then 中只接受第一个参数，第二个参数放到 catch 中解决 catch：catch是失败时调用的方法。catch只接受一个参数，即当发生错误时的回调函数。.catch() 等同于 .then(null, rejection) 或 .then(undefined, rejection) finally：finally方法不管 Promise 对象最后状态如何，在执行完 then 和 catch 指定的回调函数以后，最后都会执行 finally 方法指定的回调函数。 例： var flag = true;var promise = new Promise((resolve, reject) => { if(flag) { resolve(true); } else { reject(false); }});promise.then(() => { console.log('成功');}).catch(() => { console.log('失败');}).finally(() => { console.log('结束');});// flag = true, 成功 结束。// flag = false 失败 结束。// 都会打印出 “结束” all 和 race 方法：all的用法：.all() 接受一个 Promise 的实例数组，只有当所有全部 Promise 执行 resolve 或者有一个 reject 后才执行下面的回调函数。 当所有 Promise 都为 resolve 时： let promise1 = new Promise((resolve) => { resolve(1);});let promise2 = new Promise((resolve) => { resolve(2);});let promise3 = new Promise((resolve) => { resolve(3);});let promise4 = Promise.all([promise1,promise2,promise3]);promise4.then(value => { console.log(value);})// [1,2,3] 若某个 Promise 被拒绝了，那么会立即结束，不会等待其他 Promise 的结束： let promise1 = new Promise((resolve,reject) => { setTimeout(() => { reject(1); },1000);});let promise2 = new Promise((resolve,reject) => { setTimeout(() => { resolve(2); },2000);});let promise3 = new Promise((resolve,reject) => { setTimeout(() => { resolve(3); },3000);});let promise4 = Promise.all([promise1,promise2,promise3]);promise4.then(value => { console.log(value);}).catch(value => { console.log(value);}) // 1// 因为 promise1 为 reject，所以 .all() 会立即结束，不会等待 promise2 和 promise3 race 的用法：race 与 all 一样可以接受一个由 Promise 组成的数组作为参数，但是 race 不会等待所有 Promise 执行完成，只要数组中有一个 Promise 状态发生改变，race 方法就会立即执行回调函数，状态由最先结束的 Promise 决定。 let promise1 = new Promise((resolve,reject) => { setTimeout(() => { reject(1); },4000);});let promise2 = new Promise((resolve,reject) => { setTimeout(() => { resolve(2); },2000);});let promise3 = new Promise((resolve,reject) => { setTimeout(() => { resolve(3); },3000);});let promise4 = Promise.race([promise1,promise2,promise3]);promise4.then(value => { console.log(value);}).catch(value => { console.log(value);})// 2// promise2 延时两秒最先完成，然后立即结束，状态为resolve","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://onekx.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://onekx.github.io/tags/ES6/"}]}],"categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://onekx.github.io/tags/React-Native/"},{"name":"json-server","slug":"json-server","permalink":"http://onekx.github.io/tags/json-server/"},{"name":"Errors","slug":"Errors","permalink":"http://onekx.github.io/tags/Errors/"},{"name":"React","slug":"React","permalink":"http://onekx.github.io/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://onekx.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://onekx.github.io/tags/CSS/"},{"name":"ESLint","slug":"ESLint","permalink":"http://onekx.github.io/tags/ESLint/"},{"name":"ES6","slug":"ES6","permalink":"http://onekx.github.io/tags/ES6/"}]}