{"meta":{"title":"Kx's Blog","subtitle":"","description":"Kx 的个人博客","author":"Kx's Blog","url":"http://onekx.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-04-02T16:16:59.000Z","updated":"2020-04-04T09:10:06.616Z","comments":true,"path":"about/index.html","permalink":"http://onekx.github.io/about/index.html","excerpt":"","text":"关于博客本博客由 Hexo 强力驱动，部署在 Github Page。在平时的学习过程中，踩了很多坑，还有很多碎片化的知识，搭建博客的初衷就是为了整理笔记，记录以往遇到过的问题，进行分享。 关于我99年生人，普通本科院校学生，计算机相关专业，前端爱好者。 联系邮箱： kongxinone@163.com"},{"title":"tags","date":"2020-04-02T16:17:26.000Z","updated":"2020-04-02T16:20:18.823Z","comments":true,"path":"tags/index.html","permalink":"http://onekx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React 生命周期","slug":"life-cycle","date":"2020-04-07T07:54:09.000Z","updated":"2020-04-07T08:04:17.435Z","comments":true,"path":"post/life-cycle/","link":"","permalink":"http://onekx.github.io/post/life-cycle/","excerpt":"","text":"React 生命周期分为三个阶段： 挂载阶段、 更新阶段、 卸载阶段 挂载阶段：生命周期函数调用顺序： constructor(props){ super(props)}static getDerivedStateFromProps(props, state)render()componentDidMount() constructor组件构造函数，最先被执行，如果没有定义，会被默认生成。要在构造函数中使用 this ,就必须在构造函数第一行执行 super(props)。 构造函数作用： 初始化 state 给自定义方法绑定 this constructor(props){ super(props) this.state = { name: 'kx' } this.handleClick = this.handleClick.bind(this);} bind(this) 的作用就是保证该自定义方法的 this 始终是指向该组件，可以使用箭头函数代替它。 getDerivedStateFromProps 该方法不常用，只有当 state 的值任何时候都取决于 props 时才会使用 静态方法，函数内部不能使用 this 接受两个参数，props 和当前的 state 返回一个对象更新 state 或者 返回 null 不更新 使用该方法的时候需要初始化 state,否则会报错 state = { name: 'kx'}static getDerivedStateFromProps(props, state) { if (props.name !== state.name) { return { name: props.name } } return null} render 组件中必须包含 render() 方法。 render 是纯函数，只返回需要渲染的东西，不能在其中处理业务逻辑和数据请求。 return 中必须包含一个 UI 元素。 componentDidMount在组件挂载完成后调用，全局只调用一次，此时可以获取到 DOM 节点并进行操作。通常在该方法内进行异步请求，并可以在异步请求中进行 setState 操作。 更新阶段生命周期函数调用顺序： getDerivedStateFromProps(props, state)shouldComponentUpdate(nextProps, nextState)render()getSnapshotBeforeUpdate(prevProps, prevState)componentDidUpdate(prevProps, prevState, snapshot) getDerivedStateFromProps与挂载阶段一样 shouldComponentUpdate在组件挂载完成后，每次使用 setState 后都会调用该方法。接受两个参数，nextProps 和 nextState，表示新的 props 和 state。返回的是一个布尔值，表示是否需要重新渲染，默认返回 true shouldComponentUpdate(nextProps, nextState) { return nextState.name !== this.state.name} render当收到 shouldComponentUpdate 返回的 true 之后，render 会重新渲染 getSnapshotBeforeUpdate传入两个参数，prevProps 表示更新前的 props，prevState 表示更新前的 state必须有一个返回值，返回值将作为第三个参数传给 componentDidUpdate，如果没有可返回的值，则必须返回 null该方法必须和 componentDidUpdate 一起使用 这个函数的作用是在真实 DOM 更新（componentDidUpdate）前，获取一些需要的信息（类似快照功能），然后作为参数传给 componentDidUpdate。例如:在getSnapShotBeforeUpdate中获取滚动位置，然后作为参数传给componentDidUpdate，就可以直接在渲染真实的 DOM 时就滚动到需要的位置。 componentDidUpdate接受三个参数，之前的 props，之前的 state 以及 getSnapshotBeforeUpdate 返回的值在组件每次更新后都会调用此方法，可以在这个方法内操作 DOM，向服务器发送请求在该方法内使用 setState 时，需要使用 if 语句进行判断，否则将陷入死循环 卸载阶段componentWillUnmount卸载阶段只有这一个生命周期函数，每当React使用完一个组件，这个组件必须从 DOM 中卸载后被销毁，此时 componentWillUnmout 会被执行。可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://onekx.github.io/tags/React/"}]},{"title":"实现页面上方进度条","slug":"progress_line","date":"2020-04-05T02:43:47.000Z","updated":"2020-04-05T04:52:42.911Z","comments":true,"path":"post/progress_line/","link":"","permalink":"http://onekx.github.io/post/progress_line/","excerpt":"","text":"实现位于页面上方，跟随视图滚动而不断变化的进度条。 1. 首先在页面中添加： &lt;/div>&lt;/div> 2. 设置样式：#progress { top: 0 position: fixed width: 100% height: 0.2rem text-align: left z-index: 9999}#progress .line { width: 0% height: 0.2rem background-color: #0099ff} 3. 编写 JS 代码：$(window).scroll(function() { var pageHeight = document.documentElement.scrollHeight || document.body.scrollHeight // 页面总高度 var windowHeight = document.documentElement.clientHeight || document.body.clientHeight // 浏览器视口高度 var scrollAvail = pageHeight - windowHeight // 可滚动的高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop // 获取滚动条的高度 var ratio = (scrollTop / scrollAvail) * 100 + '%' $('#progress > .line').css('width', ratio)})","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://onekx.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://onekx.github.io/tags/CSS/"}]},{"title":"ESLint 的配置","slug":"deploy-eslint","date":"2020-04-04T07:37:39.000Z","updated":"2020-04-04T09:51:20.529Z","comments":true,"path":"post/deploy-eslint/","link":"","permalink":"http://onekx.github.io/post/deploy-eslint/","excerpt":"","text":"1. 安装所需要的包 npm install --save-dev husky lint-staged eslint 2. 如果配置文件里有使用到airbnb，通过以下命令来安装eslint-config-airbnb及它的相关依赖 npm install --save-dev eslint-config-airbnb npm install --save eslint-plugin-import eslint-plugin-react eslint-plugin-jsx-a11y 3. 设置一个配置文件 ./node_modules/.bin/eslint --init 4. 在根目录下 .eslintrc 文件中配置自己的rules，以下是我使用的配置： { \"env\": { \"browser\": true, \"es6\": true, \"node\": true }, \"extends\": [ \"airbnb\" ], \"parser\": \"babel-eslint\", \"globals\": { \"Atomics\": \"readonly\", \"SharedArrayBuffer\": \"readonly\" }, \"parserOptions\": { \"ecmaFeatures\": { \"jsx\": true, \"legacyDecorators\": true }, \"ecmaVersion\": 2018, \"sourceType\": \"module\" }, \"plugins\": [ \"react\" ], \"rules\": { \"indent\": [\"error\", 4, { \"SwitchCase\": 1,\"flatTernaryExpressions\": true }], \"max-len\": [\"error\", { \"code\": 120, \"ignoreUrls\": true }], \"react/jsx-indent\": [\"error\", 4], \"react/jsx-indent-props\": [\"error\", 4], \"react/jsx-filename-extension\": [\"warn\", { \"extensions\": [\".js\",\".jsx\"] }], \"react/prop-types\": \"off\", \"no-unused-expressions\": [\"error\", { \"allowShortCircuit\": true }], \"no-underscore-dangle\": 0, \"no-console\": [\"error\", { \"allow\": [\"log\"] }], \"react/jsx-props-no-spreading\": [\"error\", { \"custom\": \"ignore\" }], \"import/no-cycle\": 0, \"radix\": [\"error\", \"as-needed\"] } } 5. 在 package.json 文件中配置husky和lint-staged，用于提交前的检测，示例： \"husky\": { \"hooks\": { \"pre-commit\": \"lint-staged\" } }, \"lint-staged\": { \"*.js\": [ \"eslint --fix\", \"git add\" ] }","categories":[],"tags":[{"name":"ESLint","slug":"ESLint","permalink":"http://onekx.github.io/tags/ESLint/"}]},{"title":"对 Promise 的理解","slug":"about_promise","date":"2020-04-02T10:47:31.000Z","updated":"2020-04-05T03:52:28.651Z","comments":true,"path":"post/about_promise/","link":"","permalink":"http://onekx.github.io/post/about_promise/","excerpt":"","text":"以下是自己对Promise的简单理解 Promise的作用：js中使用回调函数进行事件处理，如果嵌套多层回调函数，将会陷入 回调地狱，使代码难以理解以及维护，例如： method1(function(err, result) { if (err) { throw err; } method2(function(err, result) { if (err) { throw err; } method3(function(err, result) { if (err) { throw err; } method4(function(err, result) { if (err) { throw err; } method5(result); }); }); });}); Promise就是解决以上这种问题的异步编程方案。 Promise的构造：直接在控制台中将Promise打印出来: 可以看到 Promise 包含了 resolve, reject, all, race等方法，原型上有 then, catch, finally等方法，所以当 new 一个 Promise 对象时一定包含以上方法。 Promise的三种状态： Pending（进行中），Fulfilled（已完成），Rejected（已拒绝） 当 Promise 被声明时，即处于 “Pending” 状态。接着状态的变更只能是 “Pending => Fufilled” （Fufilled对应的就是resolv方法）和 “Pending => Rejected”两种，且状态的变更是单向不可逆的。 var promise1 = new Promise((resolve, reject) => {});// Pending状态var promise2 = new Promise((resolve, reject) => resolve());// Fulfilled状态var promise3 = new Promise((resolve, reject) => reject());// Rejected状态 then 、 catch 和 finally 的用法：then：then 为返回成功时调用的方法。then 有两个参数，第一个参数是 resolved 状态的回调函数，第二个参数 (可选) 是 rejected 状态的回调函数。 建议 then 中只接受第一个参数，第二个参数放到 catch 中解决 catch：catch是失败时调用的方法。catch只接受一个参数，即当发生错误时的回调函数。.catch() 等同于 .then(null, rejection) 或 .then(undefined, rejection) finally：finally方法不管 Promise 对象最后状态如何，在执行完 then 和 catch 指定的回调函数以后，最后都会执行 finally 方法指定的回调函数。 例： var flag = true;var promise = new Promise((resolve, reject) => { if(flag) { resolve(true); } else { reject(false); }});promise.then(() => { console.log('成功');}).catch(() => { console.log('失败');}).finally(() => { console.log('结束');});// flag = true, 成功 结束。// flag = false 失败 结束。// 都会打印出 “结束” all 和 race 方法：all的用法：.all() 接受一个 Promise 的实例数组，只有当所有全部 Promise 执行 resolve 或者有一个 reject 后才执行下面的回调函数。 当所有 Promise 都为 resolve 时： let promise1 = new Promise((resolve) => { resolve(1);});let promise2 = new Promise((resolve) => { resolve(2);});let promise3 = new Promise((resolve) => { resolve(3);});let promise4 = Promise.all([promise1,promise2,promise3]);promise4.then(value => { console.log(value);})// [1,2,3] 若某个 Promise 被拒绝了，那么会立即结束，不会等待其他 Promise 的结束： let promise1 = new Promise((resolve,reject) => { setTimeout(() => { reject(1); },1000);});let promise2 = new Promise((resolve,reject) => { setTimeout(() => { resolve(2); },2000);});let promise3 = new Promise((resolve,reject) => { setTimeout(() => { resolve(3); },3000);});let promise4 = Promise.all([promise1,promise2,promise3]);promise4.then(value => { console.log(value);}).catch(value => { console.log(value);}) // 1// 因为 promise1 为 reject，所以 .all() 会立即结束，不会等待 promise2 和 promise3 race 的用法：race 与 all 一样可以接受一个由 Promise 组成的数组作为参数，但是 race 不会等待所有 Promise 执行完成，只要数组中有一个 Promise 状态发生改变，race 方法就会立即执行回调函数，状态由最先结束的 Promise 决定。 let promise1 = new Promise((resolve,reject) => { setTimeout(() => { reject(1); },4000);});let promise2 = new Promise((resolve,reject) => { setTimeout(() => { resolve(2); },2000);});let promise3 = new Promise((resolve,reject) => { setTimeout(() => { resolve(3); },3000);});let promise4 = Promise.race([promise1,promise2,promise3]);promise4.then(value => { console.log(value);}).catch(value => { console.log(value);})// 2// promise2 延时两秒最先完成，然后立即结束，状态为resolve","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://onekx.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://onekx.github.io/tags/ES6/"}]}],"categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://onekx.github.io/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://onekx.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://onekx.github.io/tags/CSS/"},{"name":"ESLint","slug":"ESLint","permalink":"http://onekx.github.io/tags/ESLint/"},{"name":"ES6","slug":"ES6","permalink":"http://onekx.github.io/tags/ES6/"}]}