{"meta":{"title":"Kx's Blog","subtitle":"","description":"","author":"Kx's Blog","url":"http://onekx.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-04-02T16:16:59.000Z","updated":"2020-04-02T16:46:41.090Z","comments":true,"path":"about/index.html","permalink":"http://onekx.github.io/about/index.html","excerpt":"","text":"it’s me,kx"},{"title":"tags","date":"2020-04-02T16:17:26.000Z","updated":"2020-04-02T16:20:18.823Z","comments":true,"path":"tags/index.html","permalink":"http://onekx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"对 Promise 的理解","slug":"about_promise","date":"2020-04-03T10:47:31.000Z","updated":"2020-04-03T10:57:55.590Z","comments":true,"path":"post/about_promise/","link":"","permalink":"http://onekx.github.io/post/about_promise/","excerpt":"","text":"以下是自己对Promise的简单理解 Promise的作用：js中使用回调函数进行事件处理，如果嵌套多层回调函数，将会陷入 回调地狱，使代码难以理解以及维护，例如： method1(function(err, result) { if (err) { throw err; } method2(function(err, result) { if (err) { throw err; } method3(function(err, result) { if (err) { throw err; } method4(function(err, result) { if (err) { throw err; } method5(result); }); }); });}); Promise就是解决以上这种问题的异步编程方案。 Promise的构造：在控制台中将Promise打印出来: 可以看到Promise对象是一个构造函数，且本身就包含了 resolve, reject, all, race等方法，原型上有 then, catch, finally等方法，所以 Promise new 出来的对象一定包含以上方法。 Promise的三种状态：Pending（进行中），Fulfilled（已完成），Rejected（已拒绝） 当Promise被声明时，即处于 “Pending” 状态，接着 只有两种状态变更 的可能 “Pending => Fufilled” （Fufilled对应的就是resolve方法）和 “Pending => Rejected”，状态的变更是单向不可逆的。 var promise1 = new Promise((resolve, reject) => {});// Pending状态var promise2 = new Promise((resolve, reject) => resolve());// Fulfilled状态var promise3 = new Promise((resolve, reject) => reject());// Rejected状态 then 、 catch 和 finally 的用法：then的用法： then可以理解为成功时调用的方法。then有两个参数，第一个参数是 resolved 状态的回调函数，第二个参数 (可选) 是 rejected 状态的回调函数。建议then中只接受第一个参数，第二个参数放到 catch 中解决 catch的用法： catch是失败时调用的方法。catch只接受一个参数，即当发生错误时的回调函数。.catch() 等同于 .then(null, rejection) 或 .then(undefined, rejection) finally的用法： finally方法用于指定不管 Promise 对象最后状态如何，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 例： var flag = true;var promise = new Promise((resolve, reject) => { if(flag) { resolve(true); } else { reject(false); }});promise.then(() => { console.log('成功');}).catch(() => { console.log('失败');}).finally(() => { console.log('结束');});// 当 flag = true 时打印出 成功 结束。// 当 flag = false 时打印出 失败 结束。 all 和 race 方法：all的用法： .all()接受一个 Promise 的示例数组，只有当所有全部 Promise 执行 resolve 或者有一个 reject 后才执行下一步。 1.当所有 Promise 都为 resolve 时： let promise1 = new Promise((resolve) => { resolve(1);});let promise2 = new Promise((resolve) => { resolve(2);});let promise3 = new Promise((resolve) => { resolve(3);});let promise4 = Promise.all([promise1,promise2,promise3]);promise4.then(value => { console.log(value);})// [1,2,3]// 在有不同延时的定时器情况下，输出的顺序仍然会按照原参数的顺序输出，还是[1,2,3] 2.若某个 Promise 被拒绝了，那么会立即结束，不会等待其他 Promise 的结束： let promise1 = new Promise((resolve,reject) => { setTimeout(() => { reject(1); },1000);});let promise2 = new Promise((resolve,reject) => { setTimeout(() => { resolve(2); },2000);});let promise3 = new Promise((resolve,reject) => { setTimeout(() => { resolve(3); },3000);});let promise4 = Promise.all([promise1,promise2,promise3]);promise4.then(value => { console.log(value);}).catch(value => { console.log(value);}) // 1// 因为 promise1 为 reject，所以 .all() 会理解结束，不会等待 promise2 和 promise3 的结束 race 的用法： race 与 all 一样可以接受一个由 Promise 组成的数组作为参数，但是 race 不会等待所有 Promise 执行完成，只要数组中有一个 Promise 状态发生改变，调用 race 方法的 Promise 就会立即改变，状态由最先结束的 Promise 决定。 let promise1 = new Promise((resolve,reject) => { setTimeout(() => { reject(1); },4000);});let promise2 = new Promise((resolve,reject) => { setTimeout(() => { resolve(2); },2000);});let promise3 = new Promise((resolve,reject) => { setTimeout(() => { resolve(3); },3000);});let promise4 = Promise.race([promise1,promise2,promise3]);promise4.then(value => { console.log(value);}).catch(value => { console.log(value);})// 2// promise2 延时两秒最先完成，然后立即结束，状态为resolve","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://onekx.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://onekx.github.io/tags/JavaScript/"}]},{"title":"博客搭建完成","slug":"blog_completed","date":"2020-04-03T09:48:59.000Z","updated":"2020-04-03T10:40:31.114Z","comments":true,"path":"post/blog_completed/","link":"","permalink":"http://onekx.github.io/post/blog_completed/","excerpt":"","text":"本博客部署在 Github Page，由 Hexo 驱动。 在平时学习过程中，很多知识过于碎片化，搭建博客的初衷就是为了记录这些以往遇到的问题，并进行分享。如果所写的内容恰巧对你有所帮助，那就更好了。 搭建暂时就先告一段落吧，以后发现有什么不满意的地方再来进行改善。","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://onekx.github.io/tags/Blog/"}]}],"categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://onekx.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://onekx.github.io/tags/JavaScript/"},{"name":"Blog","slug":"Blog","permalink":"http://onekx.github.io/tags/Blog/"}]}