{"meta":{"title":"Kx's Blog","subtitle":"","description":"Kx 的个人博客","author":"Kx's Blog","url":"http://onekx.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-04-02T16:16:59.000Z","updated":"2020-04-04T09:10:06.616Z","comments":true,"path":"about/index.html","permalink":"http://onekx.github.io/about/index.html","excerpt":"","text":"关于博客本博客由 Hexo 强力驱动，部署在 Github Page。在平时的学习过程中，踩了很多坑，还有很多碎片化的知识，搭建博客的初衷就是为了整理笔记，记录以往遇到过的问题，进行分享。 关于我99年生人，普通本科院校学生，计算机相关专业，前端爱好者。 联系邮箱： kongxinone@163.com"},{"title":"tags","date":"2020-04-02T16:17:26.000Z","updated":"2020-04-02T16:20:18.823Z","comments":true,"path":"tags/index.html","permalink":"http://onekx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"实现页面上方进度条","slug":"progress_line","date":"2020-04-05T02:43:47.000Z","updated":"2020-04-05T04:52:42.911Z","comments":true,"path":"post/progress_line/","link":"","permalink":"http://onekx.github.io/post/progress_line/","excerpt":"","text":"实现位于页面上方，跟随视图滚动而不断变化的进度条。 1. 首先在页面中添加： &lt;/div>&lt;/div> 2. 设置样式：#progress { top: 0 position: fixed width: 100% height: 0.2rem text-align: left z-index: 9999}#progress .line { width: 0% height: 0.2rem background-color: #0099ff} 3. 编写 JS 代码：$(window).scroll(function() { var pageHeight = document.documentElement.scrollHeight || document.body.scrollHeight // 页面总高度 var windowHeight = document.documentElement.clientHeight || document.body.clientHeight // 浏览器视口高度 var scrollAvail = pageHeight - windowHeight // 可滚动的高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop // 获取滚动条的高度 var ratio = (scrollTop / scrollAvail) * 100 + '%' $('#progress > .line').css('width', ratio)})","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://onekx.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://onekx.github.io/tags/CSS/"}]},{"title":"ESLint 的配置","slug":"deploy-eslint","date":"2020-04-04T07:37:39.000Z","updated":"2020-04-04T09:51:20.529Z","comments":true,"path":"post/deploy-eslint/","link":"","permalink":"http://onekx.github.io/post/deploy-eslint/","excerpt":"","text":"1. 安装所需要的包 npm install --save-dev husky lint-staged eslint 2. 如果配置文件里有使用到airbnb，通过以下命令来安装eslint-config-airbnb及它的相关依赖 npm install --save-dev eslint-config-airbnb npm install --save eslint-plugin-import eslint-plugin-react eslint-plugin-jsx-a11y 3. 设置一个配置文件 ./node_modules/.bin/eslint --init 4. 在根目录下 .eslintrc 文件中配置自己的rules，以下是我使用的配置： { \"env\": { \"browser\": true, \"es6\": true, \"node\": true }, \"extends\": [ \"airbnb\" ], \"parser\": \"babel-eslint\", \"globals\": { \"Atomics\": \"readonly\", \"SharedArrayBuffer\": \"readonly\" }, \"parserOptions\": { \"ecmaFeatures\": { \"jsx\": true, \"legacyDecorators\": true }, \"ecmaVersion\": 2018, \"sourceType\": \"module\" }, \"plugins\": [ \"react\" ], \"rules\": { \"indent\": [\"error\", 4, { \"SwitchCase\": 1,\"flatTernaryExpressions\": true }], \"max-len\": [\"error\", { \"code\": 120, \"ignoreUrls\": true }], \"react/jsx-indent\": [\"error\", 4], \"react/jsx-indent-props\": [\"error\", 4], \"react/jsx-filename-extension\": [\"warn\", { \"extensions\": [\".js\",\".jsx\"] }], \"react/prop-types\": \"off\", \"no-unused-expressions\": [\"error\", { \"allowShortCircuit\": true }], \"no-underscore-dangle\": 0, \"no-console\": [\"error\", { \"allow\": [\"log\"] }], \"react/jsx-props-no-spreading\": [\"error\", { \"custom\": \"ignore\" }], \"import/no-cycle\": 0, \"radix\": [\"error\", \"as-needed\"] } } 5. 在 package.json 文件中配置husky和lint-staged，用于提交前的检测，示例： \"husky\": { \"hooks\": { \"pre-commit\": \"lint-staged\" } }, \"lint-staged\": { \"*.js\": [ \"eslint --fix\", \"git add\" ] }","categories":[],"tags":[{"name":"ESLint","slug":"ESLint","permalink":"http://onekx.github.io/tags/ESLint/"}]},{"title":"对 Promise 的理解","slug":"about_promise","date":"2020-04-02T10:47:31.000Z","updated":"2020-04-05T03:52:28.651Z","comments":true,"path":"post/about_promise/","link":"","permalink":"http://onekx.github.io/post/about_promise/","excerpt":"","text":"以下是自己对Promise的简单理解 Promise的作用：js中使用回调函数进行事件处理，如果嵌套多层回调函数，将会陷入 回调地狱，使代码难以理解以及维护，例如： method1(function(err, result) { if (err) { throw err; } method2(function(err, result) { if (err) { throw err; } method3(function(err, result) { if (err) { throw err; } method4(function(err, result) { if (err) { throw err; } method5(result); }); }); });}); Promise就是解决以上这种问题的异步编程方案。 Promise的构造：直接在控制台中将Promise打印出来: 可以看到 Promise 包含了 resolve, reject, all, race等方法，原型上有 then, catch, finally等方法，所以当 new 一个 Promise 对象时一定包含以上方法。 Promise的三种状态： Pending（进行中），Fulfilled（已完成），Rejected（已拒绝） 当 Promise 被声明时，即处于 “Pending” 状态。接着状态的变更只能是 “Pending => Fufilled” （Fufilled对应的就是resolv方法）和 “Pending => Rejected”两种，且状态的变更是单向不可逆的。 var promise1 = new Promise((resolve, reject) => {});// Pending状态var promise2 = new Promise((resolve, reject) => resolve());// Fulfilled状态var promise3 = new Promise((resolve, reject) => reject());// Rejected状态 then 、 catch 和 finally 的用法：then：then 为返回成功时调用的方法。then 有两个参数，第一个参数是 resolved 状态的回调函数，第二个参数 (可选) 是 rejected 状态的回调函数。 建议 then 中只接受第一个参数，第二个参数放到 catch 中解决 catch：catch是失败时调用的方法。catch只接受一个参数，即当发生错误时的回调函数。.catch() 等同于 .then(null, rejection) 或 .then(undefined, rejection) finally：finally方法不管 Promise 对象最后状态如何，在执行完 then 和 catch 指定的回调函数以后，最后都会执行 finally 方法指定的回调函数。 例： var flag = true;var promise = new Promise((resolve, reject) => { if(flag) { resolve(true); } else { reject(false); }});promise.then(() => { console.log('成功');}).catch(() => { console.log('失败');}).finally(() => { console.log('结束');});// flag = true, 成功 结束。// flag = false 失败 结束。// 都会打印出 “结束” all 和 race 方法：all的用法：.all() 接受一个 Promise 的实例数组，只有当所有全部 Promise 执行 resolve 或者有一个 reject 后才执行下面的回调函数。 当所有 Promise 都为 resolve 时： let promise1 = new Promise((resolve) => { resolve(1);});let promise2 = new Promise((resolve) => { resolve(2);});let promise3 = new Promise((resolve) => { resolve(3);});let promise4 = Promise.all([promise1,promise2,promise3]);promise4.then(value => { console.log(value);})// [1,2,3] 若某个 Promise 被拒绝了，那么会立即结束，不会等待其他 Promise 的结束： let promise1 = new Promise((resolve,reject) => { setTimeout(() => { reject(1); },1000);});let promise2 = new Promise((resolve,reject) => { setTimeout(() => { resolve(2); },2000);});let promise3 = new Promise((resolve,reject) => { setTimeout(() => { resolve(3); },3000);});let promise4 = Promise.all([promise1,promise2,promise3]);promise4.then(value => { console.log(value);}).catch(value => { console.log(value);}) // 1// 因为 promise1 为 reject，所以 .all() 会立即结束，不会等待 promise2 和 promise3 race 的用法：race 与 all 一样可以接受一个由 Promise 组成的数组作为参数，但是 race 不会等待所有 Promise 执行完成，只要数组中有一个 Promise 状态发生改变，race 方法就会立即执行回调函数，状态由最先结束的 Promise 决定。 let promise1 = new Promise((resolve,reject) => { setTimeout(() => { reject(1); },4000);});let promise2 = new Promise((resolve,reject) => { setTimeout(() => { resolve(2); },2000);});let promise3 = new Promise((resolve,reject) => { setTimeout(() => { resolve(3); },3000);});let promise4 = Promise.race([promise1,promise2,promise3]);promise4.then(value => { console.log(value);}).catch(value => { console.log(value);})// 2// promise2 延时两秒最先完成，然后立即结束，状态为resolve","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://onekx.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://onekx.github.io/tags/ES6/"}]}],"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://onekx.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://onekx.github.io/tags/CSS/"},{"name":"ESLint","slug":"ESLint","permalink":"http://onekx.github.io/tags/ESLint/"},{"name":"ES6","slug":"ES6","permalink":"http://onekx.github.io/tags/ES6/"}]}