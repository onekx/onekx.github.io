<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kx&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://onekx.github.io/"/>
  <updated>2020-04-13T13:17:09.385Z</updated>
  <id>http://onekx.github.io/</id>
  
  <author>
    <name>Kx&#39;s Blog</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 生命周期</title>
    <link href="http://onekx.github.io/post/life_cycle/"/>
    <id>http://onekx.github.io/post/life_cycle/</id>
    <published>2020-04-07T07:54:09.000Z</published>
    <updated>2020-04-13T13:17:09.385Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><a href="../../../images/生命周期.png" data-caption data-fancybox="images"><img src="../../../images/生命周期.png" alt></a><blockquote><p>React 生命周期分为三个阶段： 挂载阶段、 更新阶段、 卸载阶段</p></blockquote><h2 id="挂载阶段：">挂载阶段：<a class="post-anchor" href="#挂载阶段："></a></h2><p><strong>生命周期函数调用顺序：</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">constructor</span>(props){<br>    <span class="hljs-keyword">super</span>(props)<br>}<br><br><span class="hljs-keyword">static</span> getDerivedStateFromProps(props, state)<br><br>render()<br><br>componentDidMount()<br></code></pre></td></tr></tbody></table></figure><h3 id="constructor-NaN">constructor<a class="post-anchor" href="#constructor-NaN"></a></h3><p>组件构造函数，最先被执行，如果没有定义，会被默认生成。要在构造函数中使用 this ,就必须在构造函数第一行执行 super(props)。  </p><p>构造函数作用：</p><ol><li>初始化 state</li><li>给自定义方法绑定 this</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">constructor</span>(props){<br>    <span class="hljs-keyword">super</span>(props)<br>    <span class="hljs-keyword">this</span>.state = {<br>        name: <span class="hljs-string">'kx'</span><br>    }<br>    <span class="hljs-keyword">this</span>.handleClick = <span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>bind(this) 的作用就是保证该自定义方法的 this 始终是指向该组件，可以使用箭头函数代替它。</p><h3 id="getDerivedStateFromProps">getDerivedStateFromProps<a class="post-anchor" href="#getDerivedStateFromProps"></a></h3><ul><li>该方法不常用，只有当 state 的值任何时候都取决于 props 时才会使用  </li><li>静态方法，函数内部不能使用 this  </li><li>接受两个参数，props 和当前的 state</li><li>返回一个对象更新 state 或者 返回 null 不更新</li><li>使用该方法的时候需要初始化 state,否则会报错</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">state = {<br>  name: <span class="hljs-string">'kx'</span><br>}<br><br><span class="hljs-keyword">static</span> getDerivedStateFromProps(props, state) {<br>  <span class="hljs-keyword">if</span> (props.name !== state.name) {<br>    <span class="hljs-keyword">return</span> {<br>      name: props.name<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="render">render<a class="post-anchor" href="#render"></a></h3><ul><li>组件中必须包含 render() 方法。  </li><li>render 是纯函数，只返回需要渲染的东西，不能在其中处理业务逻辑和数据请求。</li><li>return 中必须包含一个 UI 元素。</li></ul><h3 id="componentDidMount">componentDidMount<a class="post-anchor" href="#componentDidMount"></a></h3><p>在组件挂载完成后调用，全局只调用一次，此时可以获取到 DOM 节点并进行操作。<br>通常在该方法内进行异步请求，并可以在异步请求中进行 setState 操作。</p><h2 id="更新阶段">更新阶段<a class="post-anchor" href="#更新阶段"></a></h2><p><strong>生命周期函数调用顺序：</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">getDerivedStateFromProps(props, state)<br><br>shouldComponentUpdate(nextProps, nextState)<br><br>render()<br><br>getSnapshotBeforeUpdate(prevProps, prevState)<br><br>componentDidUpdate(prevProps, prevState, snapshot)<br></code></pre></td></tr></tbody></table></figure><h3 id="getDerivedStateFromProps-1">getDerivedStateFromProps<a class="post-anchor" href="#getDerivedStateFromProps-1"></a></h3><p>与挂载阶段一样</p><h3 id="shouldComponentUpdate">shouldComponentUpdate<a class="post-anchor" href="#shouldComponentUpdate"></a></h3><p>在组件挂载完成后，每次使用 setState 后都会调用该方法。<br>接受两个参数，nextProps 和 nextState，表示新的 props 和 state。<br>返回的是一个布尔值，表示是否需要重新渲染，默认返回 true</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">shouldComponentUpdate(nextProps, nextState) {<br>    <span class="hljs-keyword">return</span> nextState.name !== <span class="hljs-keyword">this</span>.state.name<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="render-1">render<a class="post-anchor" href="#render-1"></a></h3><p>当收到 shouldComponentUpdate 返回的 true 之后，render 会重新渲染</p><h3 id="getSnapshotBeforeUpdate">getSnapshotBeforeUpdate<a class="post-anchor" href="#getSnapshotBeforeUpdate"></a></h3><p>传入两个参数，prevProps 表示更新前的 props，prevState 表示更新前的 state<br>必须有一个返回值，返回值将作为第三个参数传给 componentDidUpdate，如果没有可返回的值，则必须返回 null<br>该方法必须和 componentDidUpdate 一起使用</p><blockquote><p>这个函数的作用是在真实 DOM 更新（componentDidUpdate）前，获取一些需要的信息（类似快照功能），然后作为参数传给 componentDidUpdate。例如:在getSnapShotBeforeUpdate中获取滚动位置，然后作为参数传给componentDidUpdate，就可以直接在渲染真实的 DOM 时就滚动到需要的位置。</p></blockquote><h3 id="componentDidUpdate">componentDidUpdate<a class="post-anchor" href="#componentDidUpdate"></a></h3><p>接受三个参数，之前的 props，之前的 state 以及 getSnapshotBeforeUpdate 返回的值<br>在组件每次更新后都会调用此方法，可以在这个方法内操作 DOM，向服务器发送请求<br>在该方法内使用 setState 时，需要使用 if 语句进行判断，否则将陷入死循环</p><h2 id="卸载阶段">卸载阶段<a class="post-anchor" href="#卸载阶段"></a></h2><h3 id="componentWillUnmount">componentWillUnmount<a class="post-anchor" href="#componentWillUnmount"></a></h3><p>卸载阶段只有这一个生命周期函数，每当React使用完一个组件，这个组件必须从 DOM 中卸载后被销毁，此时 componentWillUnmout 会被执行。<br>可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;../../../images/生命周期.png&quot; data-caption data-fancybox=&quot;images&quot;&gt;&lt;img src=&quot;../../../images/生命周期.png&quot; alt&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
      <category term="React" scheme="http://onekx.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>实现页面上方进度条</title>
    <link href="http://onekx.github.io/post/progress_line/"/>
    <id>http://onekx.github.io/post/progress_line/</id>
    <published>2020-04-05T02:43:47.000Z</published>
    <updated>2020-04-05T04:52:42.911Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p>实现位于页面上方，跟随视图滚动而不断变化的进度条。</p></blockquote><h5 id="1-首先在页面中添加：">1. 首先在页面中添加：<a class="post-anchor" href="#1-首先在页面中添加："></a></h5><figure class="highlight html"><table><tbody><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"progress"</span>></span><br>    <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"line"</span>></span><span class="hljs-symbol">&lt;</span>/div><br><span class="hljs-symbol">&lt;</span>/div><br></code></pre></td></tr></tbody></table></figure><h5 id="2-设置样式：">2. 设置样式：<a class="post-anchor" href="#2-设置样式："></a></h5><figure class="highlight css"><table><tbody><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#progress</span> {<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span><br>    position: fixed<br>    width: <span class="hljs-number">100%</span><br>    height: <span class="hljs-number">0.2rem</span><br>    text-align: left<br>    z-index: <span class="hljs-number">9999</span><br>}<br><br><span class="hljs-selector-id">#progress</span> <span class="hljs-selector-class">.line</span> {<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0%</span><br>    height: <span class="hljs-number">0.2rem</span><br>    background-color: <span class="hljs-number">#0099ff</span><br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="3-编写-JS-代码：">3. 编写 JS 代码：<a class="post-anchor" href="#3-编写-JS-代码："></a></h5><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs JavaScript">$(<span class="hljs-built_in">window</span>).scroll(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>      <span class="hljs-keyword">var</span> pageHeight = <span class="hljs-built_in">document</span>.documentElement.scrollHeight || <span class="hljs-built_in">document</span>.body.scrollHeight <span class="hljs-comment">// 页面总高度</span><br>      <span class="hljs-keyword">var</span> windowHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight || <span class="hljs-built_in">document</span>.body.clientHeight <span class="hljs-comment">// 浏览器视口高度</span><br>      <span class="hljs-keyword">var</span> scrollAvail = pageHeight - windowHeight <span class="hljs-comment">// 可滚动的高度</span><br>      <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop <span class="hljs-comment">// 获取滚动条的高度</span><br>      <span class="hljs-keyword">var</span> ratio = (scrollTop / scrollAvail) * <span class="hljs-number">100</span> + <span class="hljs-string">'%'</span><br>      $(<span class="hljs-string">'#progress > .line'</span>).css(<span class="hljs-string">'width'</span>, ratio)<br>})<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt;实现位于页面上方，跟随视图滚动而不断变化的进度条。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;1-首先在页面中添加：&quot;&gt;1. 首先在页面中添加：&lt;a class=&quot;post-anchor&quot;
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://onekx.github.io/tags/JavaScript/"/>
    
      <category term="CSS" scheme="http://onekx.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>ESLint 的配置</title>
    <link href="http://onekx.github.io/post/deploy_eslint/"/>
    <id>http://onekx.github.io/post/deploy_eslint/</id>
    <published>2020-04-04T07:37:39.000Z</published>
    <updated>2020-04-13T13:16:59.818Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h4 id="1-安装所需要的包">1. 安装所需要的包<a class="post-anchor" href="#1-安装所需要的包"></a></h4>   <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><code class="hljs shell">npm install --save-dev husky lint-staged eslint<br></code></pre></td></tr></tbody></table></figure><h4 id="2-如果配置文件里有使用到airbnb，通过以下命令来安装eslint-config-airbnb及它的相关依赖">2. 如果配置文件里有使用到airbnb，通过以下命令来安装eslint-config-airbnb及它的相关依赖<a class="post-anchor" href="#2-如果配置文件里有使用到airbnb，通过以下命令来安装eslint-config-airbnb及它的相关依赖"></a></h4>   <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><code class="hljs shell">npm install --save-dev eslint-config-airbnb  <br>npm install --save eslint-plugin-import eslint-plugin-react eslint-plugin-jsx-a11y<br></code></pre></td></tr></tbody></table></figure><h4 id="3-设置一个配置文件">3. 设置一个配置文件<a class="post-anchor" href="#3-设置一个配置文件"></a></h4>   <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><code class="hljs shell">./node_modules/.bin/eslint --init<br></code></pre></td></tr></tbody></table></figure><h4 id="4-在根目录下-eslintrc-文件中配置自己的rules，以下是我使用的配置：">4. 在根目录下 .eslintrc 文件中配置自己的rules，以下是我使用的配置：<a class="post-anchor" href="#4-在根目录下-eslintrc-文件中配置自己的rules，以下是我使用的配置："></a></h4>   <figure class="highlight json"><table><tbody><tr><td class="code"><pre><code class="hljs json">{  <br> <span class="hljs-attr">"env"</span>: {  <br>     <span class="hljs-attr">"browser"</span>: <span class="hljs-literal">true</span>,  <br>     <span class="hljs-attr">"es6"</span>: <span class="hljs-literal">true</span>,  <br>     <span class="hljs-attr">"node"</span>: <span class="hljs-literal">true</span>  <br> },  <br> <span class="hljs-attr">"extends"</span>: [  <br>     <span class="hljs-string">"airbnb"</span>  <br> ],  <br> <span class="hljs-attr">"parser"</span>: <span class="hljs-string">"babel-eslint"</span>,  <br> <span class="hljs-attr">"globals"</span>: {  <br>     <span class="hljs-attr">"Atomics"</span>: <span class="hljs-string">"readonly"</span>,  <br>     <span class="hljs-attr">"SharedArrayBuffer"</span>: <span class="hljs-string">"readonly"</span>  <br> },  <br> <span class="hljs-attr">"parserOptions"</span>: {  <br>     <span class="hljs-attr">"ecmaFeatures"</span>: {  <br>         <span class="hljs-attr">"jsx"</span>: <span class="hljs-literal">true</span>,  <br>         <span class="hljs-attr">"legacyDecorators"</span>: <span class="hljs-literal">true</span>  <br>     },  <br>     <span class="hljs-attr">"ecmaVersion"</span>: <span class="hljs-number">2018</span>,  <br>     <span class="hljs-attr">"sourceType"</span>: <span class="hljs-string">"module"</span>  <br> },  <br> <span class="hljs-attr">"plugins"</span>: [  <br>     <span class="hljs-string">"react"</span>  <br> ],  <br> <span class="hljs-attr">"rules"</span>: {  <br>     <span class="hljs-attr">"indent"</span>: [<span class="hljs-string">"error"</span>, <span class="hljs-number">4</span>, { <span class="hljs-attr">"SwitchCase"</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">"flatTernaryExpressions"</span>: <span class="hljs-literal">true</span> }],  <br>     <span class="hljs-attr">"max-len"</span>: [<span class="hljs-string">"error"</span>, { <span class="hljs-attr">"code"</span>: <span class="hljs-number">120</span>, <span class="hljs-attr">"ignoreUrls"</span>: <span class="hljs-literal">true</span> }],  <br>     <span class="hljs-attr">"react/jsx-indent"</span>: [<span class="hljs-string">"error"</span>, <span class="hljs-number">4</span>],  <br>     <span class="hljs-attr">"react/jsx-indent-props"</span>: [<span class="hljs-string">"error"</span>, <span class="hljs-number">4</span>],  <br>     <span class="hljs-attr">"react/jsx-filename-extension"</span>: [<span class="hljs-string">"warn"</span>, { <span class="hljs-attr">"extensions"</span>: [<span class="hljs-string">".js"</span>,<span class="hljs-string">".jsx"</span>] }],  <br>     <span class="hljs-attr">"react/prop-types"</span>: <span class="hljs-string">"off"</span>,  <br>     <span class="hljs-attr">"no-unused-expressions"</span>: [<span class="hljs-string">"error"</span>, { <span class="hljs-attr">"allowShortCircuit"</span>: <span class="hljs-literal">true</span> }],  <br>     <span class="hljs-attr">"no-underscore-dangle"</span>: <span class="hljs-number">0</span>,  <br>     <span class="hljs-attr">"no-console"</span>: [<span class="hljs-string">"error"</span>, { <span class="hljs-attr">"allow"</span>: [<span class="hljs-string">"log"</span>] }],  <br>     <span class="hljs-attr">"react/jsx-props-no-spreading"</span>: [<span class="hljs-string">"error"</span>, { <span class="hljs-attr">"custom"</span>: <span class="hljs-string">"ignore"</span> }],  <br>     <span class="hljs-attr">"import/no-cycle"</span>: <span class="hljs-number">0</span>,  <br>     <span class="hljs-attr">"radix"</span>: [<span class="hljs-string">"error"</span>, <span class="hljs-string">"as-needed"</span>]  <br> }  <br> }<br></code></pre></td></tr></tbody></table></figure><h4 id="5-在-package-json-文件中配置husky和lint-staged，用于提交前的检测，示例：">5. 在 package.json 文件中配置husky和lint-staged，用于提交前的检测，示例：<a class="post-anchor" href="#5-在-package-json-文件中配置husky和lint-staged，用于提交前的检测，示例："></a></h4>   <figure class="highlight"><table><tbody><tr><td class="code"><pre><code class="hljs json">"husky": {  <br>    "hooks": {    <br>        "pre-commit": "lint-staged"  <br>     }<br> },<br> "lint-staged": {  <br>     "*.js": [    <br>         "eslint --fix",    <br>         <span class="hljs-string">"git add"</span>  <br>     ]<br> }<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h4 id=&quot;1-安装所需要的包&quot;&gt;1. 安装所需要的包&lt;a class=&quot;post-anchor&quot; href=&quot;#1-安装所需要的包&quot;&gt;&lt;/a&gt;&lt;/h4&gt;   &lt;figure class=&quot;highlight shell&quot;&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="ESLint" scheme="http://onekx.github.io/tags/ESLint/"/>
    
  </entry>
  
  <entry>
    <title>对 Promise 的理解</title>
    <link href="http://onekx.github.io/post/about_promise/"/>
    <id>http://onekx.github.io/post/about_promise/</id>
    <published>2020-04-02T10:47:31.000Z</published>
    <updated>2020-04-05T03:52:28.651Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><a href="../../../images/Promise.png" data-caption data-fancybox="images"><img src="../../../images/Promise.png" alt></a><hr><p><strong>以下是自己对Promise的简单理解</strong></p><h3 id="Promise的作用：">Promise的作用：<a class="post-anchor" href="#Promise的作用："></a></h3><p>js中使用回调函数进行事件处理，如果嵌套多层回调函数，将会陷入 回调地狱，使代码难以理解以及维护，例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">method1(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>) </span>{<br>    <span class="hljs-keyword">if</span> (err) {<br>        <span class="hljs-keyword">throw</span> err;<br>    } <br>    method2(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>) </span>{<br>        <span class="hljs-keyword">if</span> (err) {<br>            <span class="hljs-keyword">throw</span> err;<br>        } <br>        method3(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>) </span>{<br>            <span class="hljs-keyword">if</span> (err) {<br>                <span class="hljs-keyword">throw</span> err;<br>            } <br>            method4(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>) </span>{<br>                <span class="hljs-keyword">if</span> (err) {<br>                    <span class="hljs-keyword">throw</span> err;<br>                } <br>                method5(result);<br>            });<br>        });<br>    });<br>});<br></code></pre></td></tr></tbody></table></figure><p><strong>Promise就是解决以上这种问题的异步编程方案。</strong></p><hr><h3 id="Promise的构造：">Promise的构造：<a class="post-anchor" href="#Promise的构造："></a></h3><p>直接在控制台中将Promise打印出来:</p><a href="../../../images/Promise的结构.png" data-caption data-fancybox="images"><img src="../../../images/Promise的结构.png" alt></a><p>可以看到 Promise 包含了 resolve, reject, all, race等方法，原型上有 then, catch, finally等方法，所以当 new 一个 Promise 对象时一定包含以上方法。</p><hr><h3 id="Promise的三种状态：">Promise的三种状态：<a class="post-anchor" href="#Promise的三种状态："></a></h3><blockquote><p>Pending（进行中），Fulfilled（已完成），Rejected（已拒绝）</p></blockquote><p>当 Promise 被声明时，即处于 <strong>“Pending”</strong> 状态。<br>接着状态的变更只能是 <strong>“Pending => Fufilled”</strong> （Fufilled对应的就是resolv方法）和 <strong>“Pending => Rejected”</strong>两种，<strong>且状态的变更是单向不可逆的</strong>。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {});<br><span class="hljs-comment">// Pending状态</span><br><span class="hljs-keyword">var</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> resolve());<br><span class="hljs-comment">// Fulfilled状态</span><br><span class="hljs-keyword">var</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> reject());<br><span class="hljs-comment">// Rejected状态</span><br></code></pre></td></tr></tbody></table></figure><hr><h3 id="then-、-catch-和-finally-的用法：">then 、 catch 和 finally 的用法：<a class="post-anchor" href="#then-、-catch-和-finally-的用法："></a></h3><h4 id="then：">then：<a class="post-anchor" href="#then："></a></h4><p>then 为返回成功时调用的方法。<br>then 有两个参数，第一个参数是 resolved 状态的回调函数，第二个参数 <strong>(可选)</strong> 是 rejected 状态的回调函数。</p><blockquote><p>建议 then 中只接受第一个参数，第二个参数放到 catch 中解决</p></blockquote><h4 id="catch：">catch：<a class="post-anchor" href="#catch："></a></h4><p>catch是失败时调用的方法。catch只接受一个参数，即当发生错误时的回调函数。<br><strong>.catch()</strong>  等同于 <strong>.then(null, rejection)</strong> 或 <strong>.then(undefined, rejection)</strong></p><h4 id="finally：">finally：<a class="post-anchor" href="#finally："></a></h4><p>finally方法不管 Promise 对象最后状态如何，在执行完 then 和 catch 指定的回调函数以后，最后都会执行 finally 方法指定的回调函数。</p><p>例：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {<br>    <span class="hljs-keyword">if</span>(flag) {<br>        resolve(<span class="hljs-literal">true</span>);<br>    } <span class="hljs-keyword">else</span> {<br>        reject(<span class="hljs-literal">false</span>);<br>    }<br>});<br><br>promise.then(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功'</span>);<br>}).catch(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败'</span>);<br>}).finally(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'结束'</span>);<br>});<br><br><span class="hljs-comment">// flag = true, 成功 结束。</span><br><span class="hljs-comment">// flag = false 失败 结束。</span><br><span class="hljs-comment">// 都会打印出 “结束”</span><br></code></pre></td></tr></tbody></table></figure><hr><h3 id="all-和-race-方法：">all 和 race 方法：<a class="post-anchor" href="#all-和-race-方法："></a></h3><h4 id="all的用法：">all的用法：<a class="post-anchor" href="#all的用法："></a></h4><p>.all() 接受一个 Promise 的实例数组，只有当所有全部 Promise 执行 resolve 或者有一个 reject 后才执行下面的回调函数。</p><ol><li>当所有 Promise 都为 resolve 时：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {<br>    resolve(<span class="hljs-number">1</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {<br>    resolve(<span class="hljs-number">2</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {<br>    resolve(<span class="hljs-number">3</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise4 = <span class="hljs-built_in">Promise</span>.all([promise1,promise2,promise3]);<br>promise4.then(<span class="hljs-function"><span class="hljs-params">value</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(value);<br>})<br><br><span class="hljs-comment">// [1,2,3]</span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>若某个 Promise 被拒绝了，那么会立即结束，不会等待其他 Promise 的结束：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        reject(<span class="hljs-number">1</span>);<br>    },<span class="hljs-number">1000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        resolve(<span class="hljs-number">2</span>);<br>    },<span class="hljs-number">2000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        resolve(<span class="hljs-number">3</span>);<br>    },<span class="hljs-number">3000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise4 = <span class="hljs-built_in">Promise</span>.all([promise1,promise2,promise3]);<br>promise4.then(<span class="hljs-function"><span class="hljs-params">value</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(value);<br>}).catch(<span class="hljs-function"><span class="hljs-params">value</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(value);<br>})<br>    <br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 因为 promise1 为 reject，所以 .all() 会立即结束，不会等待 promise2 和 promise3</span><br></code></pre></td></tr></tbody></table></figure><h4 id="race-的用法：">race 的用法：<a class="post-anchor" href="#race-的用法："></a></h4><p>race 与 all 一样可以接受一个由 Promise 组成的数组作为参数，但是 race 不会等待所有 Promise 执行完成，只要数组中有一个 Promise 状态发生改变，race 方法就会立即执行回调函数，状态由最先结束的 Promise 决定。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        reject(<span class="hljs-number">1</span>);<br>    },<span class="hljs-number">4000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        resolve(<span class="hljs-number">2</span>);<br>    },<span class="hljs-number">2000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        resolve(<span class="hljs-number">3</span>);<br>    },<span class="hljs-number">3000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise4 = <span class="hljs-built_in">Promise</span>.race([promise1,promise2,promise3]);<br>promise4.then(<span class="hljs-function"><span class="hljs-params">value</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(value);<br>}).catch(<span class="hljs-function"><span class="hljs-params">value</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(value);<br>})<br><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// promise2 延时两秒最先完成，然后立即结束，状态为resolve</span><br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;../../../images/Promise.png&quot; data-caption data-fancybox=&quot;images&quot;&gt;&lt;img src=&quot;../../../images/Promise.png&quot; al
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://onekx.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://onekx.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
