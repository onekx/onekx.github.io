<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kx&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://onekx.github.io/"/>
  <updated>2020-04-25T11:57:55.601Z</updated>
  <id>http://onekx.github.io/</id>
  
  <author>
    <name>Kx&#39;s Blog</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 json-server 模拟服务器</title>
    <link href="http://onekx.github.io/post/json-server/"/>
    <id>http://onekx.github.io/post/json-server/</id>
    <published>2020-04-25T11:41:33.000Z</published>
    <updated>2020-04-25T11:57:55.601Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>利用 json-server 模拟服务器，可以进行数据的请求。</p><h3 id="1-全局安装-json-server">1. 全局安装 json-server<a class="post-anchor" href="#1-全局安装-json-server"></a></h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><code class="hljs shell">npm install -g json-server<br></code></pre></td></tr></tbody></table></figure><h3 id="2-在项目目录下创建-server-文件夹和-db-json-文件，如下：">2. 在项目目录下创建 server 文件夹和 db.json 文件，如下：<a class="post-anchor" href="#2-在项目目录下创建-server-文件夹和-db-json-文件，如下："></a></h3><div style="width: 300px; margin: 0 auto"><a href="../../../images/json_server.png" data-caption data-fancybox="images"><img src="../../../images/json_server.png" alt></a></div><div style="width: 300px; margin: 0 auto"><a href="../../../images/db_json.png" data-caption data-fancybox="images"><img src="../../../images/db_json.png" alt></a></div><h3 id="3-进入-server-目录下，启动服务">3. 进入 server 目录下，启动服务<a class="post-anchor" href="#3-进入-server-目录下，启动服务"></a></h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><code class="hljs shell">cd server<br></code></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><code class="hljs shell">json-server db.json<br></code></pre></td></tr></tbody></table></figure><p><strong>默认是 3000 端口，可以在命令中加 <code>--port</code> 参数改变端口,如<code>json-server --port 5000 db.json</code>将在 5000 端口启动服务。</strong></p><p><strong>之后就可以请求 <a href="http://localhost:3000/result" target="_blank" rel="noopener">http://localhost:3000/result</a> 来获取数据。</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;利用 json-server 模拟服务器，可以进行数据的请求。&lt;/p&gt;
&lt;h3 id=&quot;1-全局安装-json-server&quot;&gt;1. 全局安装 json-server&lt;a class=&quot;post-anchor&quot; href=&quot;
      
    
    </summary>
    
    
    
      <category term="json-server" scheme="http://onekx.github.io/tags/json-server/"/>
    
  </entry>
  
  <entry>
    <title>修改 apk 相关信息</title>
    <link href="http://onekx.github.io/post/change-apk/"/>
    <id>http://onekx.github.io/post/change-apk/</id>
    <published>2020-04-23T05:30:24.000Z</published>
    <updated>2020-04-23T06:18:50.910Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h3 id="修改-app-名字">修改 app 名字<a class="post-anchor" href="#修改-app-名字"></a></h3><p>打开项目下的 <strong>./android/app/src/main/res/values/strings.xml</strong> 文件</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag"><<span class="hljs-name">resources</span>></span><br>    <span class="hljs-tag"><<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"app_name"</span>></span> ***** &lt/string><br>&lt/resources><br></code></pre></td></tr></tbody></table></figure><p>将其中的 ***** 替换为自己 app 的名字</p><h3 id="修改-app-图标">修改 app 图标<a class="post-anchor" href="#修改-app-图标"></a></h3><p>首先制作不同分辨率下的图标，生成以下目录（推荐网站：<a href="https://icon.wuruihong.com/" target="_blank" rel="noopener">图标工厂</a> ）：</p><div style="width: 250px; margin: auto"><a href="../../../images/图标工厂.png" data-caption data-fancybox="images"><img src="../../../images/图标工厂.png" alt></a></div><p>打开项目下的 <strong>./android/app/src/main/res</strong> 文件夹，用自己制作的文件替换掉 <strong>res</strong> 目录下的文件</p><h3 id="减小-apk-文件的大小">减小 apk 文件的大小<a class="post-anchor" href="#减小-apk-文件的大小"></a></h3><p>打开项目下 <strong>./android/app/build.gradle</strong> 文件，<strong>将下面两个 false 改为 true</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">def enableSeparateBuildPerCPUArchitecture = <span class="hljs-literal">false</span> <span class="hljs-comment">//更改为 true</span><br><br>def enableProguardInReleaseBuilds = <span class="hljs-literal">false</span> <span class="hljs-comment">//更改为 true</span><br></code></pre></td></tr></tbody></table></figure><ul><li>enableSeparateBuildPerCPUArchitecture 会生成多个适应不同 CPU 架构的包</li><li>如果想额外生成一个适应所有 CPU 架构的 apk ，则将文件中的 <code>universalApk false</code> 修改为 <code>universalApk true</code></li><li>enableProguardInReleaseBuilds 会移除掉 React Native Java（和它的依赖库中）中没有被使用到的部分，最终减少 apk 的大小。</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 id=&quot;修改-app-名字&quot;&gt;修改 app 名字&lt;a class=&quot;post-anchor&quot; href=&quot;#修改-app-名字&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;打开项目下的 &lt;strong&gt;./android/app/src/m
      
    
    </summary>
    
    
    
      <category term="React-Native" scheme="http://onekx.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>报错：&#39;app:installDebug&#39;</title>
    <link href="http://onekx.github.io/post/install_debug/"/>
    <id>http://onekx.github.io/post/install_debug/</id>
    <published>2020-04-23T03:47:16.000Z</published>
    <updated>2020-04-23T05:41:15.405Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>当我在更新项目后，尝试重新打包 apk 时，报了下面的错误：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><code class="hljs plain">* What went wrong:<br>Execution failed for task ':app:installDebug'.<br>> com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package com.rndemo signatures do not match previously installed version; ignoring!<br></code></pre></td></tr></tbody></table></figure><p>原因是设备上存在的旧版本与此时的新版本冲突了。<br>解决办法：删除设备上的旧版本 App 或者清除虚拟设备的数据，然后重新打包</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;当我在更新项目后，尝试重新打包 apk 时，报了下面的错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code
      
    
    </summary>
    
    
    
      <category term="React-Native" scheme="http://onekx.github.io/tags/React-Native/"/>
    
      <category term="Errors" scheme="http://onekx.github.io/tags/Errors/"/>
    
  </entry>
  
  <entry>
    <title>react-native 打包 apk 文件</title>
    <link href="http://onekx.github.io/post/apk/"/>
    <id>http://onekx.github.io/post/apk/</id>
    <published>2020-04-22T11:10:46.000Z</published>
    <updated>2020-04-22T12:40:26.334Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h3 id="1-生成签名密钥：">1. 生成签名密钥：<a class="post-anchor" href="#1-生成签名密钥："></a></h3><p>打开 CMD ,输入下面一行命令:</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><code class="hljs shell">keytool -genkeypair -v -keystore onekx.keystore -alias kx -keyalg RSA -keysize 2048 -validity 10000<br></code></pre></td></tr></tbody></table></figure><ul><li><strong>onekx.keystore</strong> 是待会儿会生成的密钥文件</li><li><code>-alias</code>后的别名 <strong>kx</strong> 后面应用签名时会使用</li><li><code>-validity</code>后的 10000 表示此密钥有效期 10000 天</li></ul><p>随后会要求输入以下问题：<strong>(必须将以下问题的回答都详细记录备份)</strong></p><ol><li>输入密钥库口令</li><li>再次输入新口令</li><li>名字与姓氏</li><li>组织单位名称</li><li>组织名称</li><li>所在城市区域名称</li><li>所在省/市/自治区名称</li><li>国家/地区代码</li><li>是否正确？<strong>(此时在命令行输入: 是)</strong> </li></ol><p>然后会生成一个 onekx.keystore 的文件，路径: <code>C:\用户\***</code></p><h3 id="2-设置-gradle-变量">2. 设置 gradle 变量:<a class="post-anchor" href="#2-设置-gradle-变量"></a></h3><ul><li>将 onekx.keystore 文件复制到项目的 android/app 目录下</li><li>打开 ./android/app/gradle/gradle.properties 文件，在文件中加入如下代码，并把其中的*****替换为相应密码：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><code class="hljs plain">MYAPP_RELEASE_STORE_FILE=onekx.keystore<br>MYAPP_RELEASE_KEY_ALIAS=kx<br>MYAPP_RELEASE_STORE_PASSWORD=*****<br>MYAPP_RELEASE_KEY_PASSWORD=*****<br></code></pre></td></tr></tbody></table></figure><h3 id="3-添加签名到应用的gradle配置中：">3. 添加签名到应用的gradle配置中：<a class="post-anchor" href="#3-添加签名到应用的gradle配置中："></a></h3><p>打开 ./android/app/build.gradle 文件,添加如下代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">...<br>android {<br>    ...<br>    defaultConfig { ... }<br>    signingConfigs {<br>        release {<br>            <span class="hljs-keyword">if</span> (project.hasProperty(<span class="hljs-string">'MYAPP_RELEASE_STORE_FILE'</span>)) {<br>                storeFile file(MYAPP_RELEASE_STORE_FILE)<br>                storePassword MYAPP_RELEASE_STORE_PASSWORD<br>                keyAlias MYAPP_RELEASE_KEY_ALIAS<br>                keyPassword MYAPP_RELEASE_KEY_PASSWORD<br>            }<br>        }<br>    }<br>    buildTypes {<br>        release {<br>            ...<br>            signingConfig signingConfigs.release<br>        }<br>    }<br>}<br>...<br></code></pre></td></tr></tbody></table></figure><h3 id="4-生成-release-版本的-APK-包：">4. 生成 release 版本的 APK 包：<a class="post-anchor" href="#4-生成-release-版本的-APK-包："></a></h3><p>打开终端，进入项目下的 ./android 目录，运行如下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><code class="hljs shell">./gradlew assembleRelease<br></code></pre></td></tr></tbody></table></figure><p>此时会生成一个 <strong>app-release.apk</strong> 文件，就是软件的安装包，位于：<strong>./android/app/build/outputs/apk/release</strong> 目录下，打包完成。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 id=&quot;1-生成签名密钥：&quot;&gt;1. 生成签名密钥：&lt;a class=&quot;post-anchor&quot; href=&quot;#1-生成签名密钥：&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;打开 CMD ,输入下面一行命令:&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
    
      <category term="React-Native" scheme="http://onekx.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>React 生命周期</title>
    <link href="http://onekx.github.io/post/life_cycle/"/>
    <id>http://onekx.github.io/post/life_cycle/</id>
    <published>2020-04-07T07:54:09.000Z</published>
    <updated>2020-04-13T13:17:09.385Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><a href="../../../images/生命周期.png" data-caption data-fancybox="images"><img src="../../../images/生命周期.png" alt></a><blockquote><p>React 生命周期分为三个阶段： 挂载阶段、 更新阶段、 卸载阶段</p></blockquote><h2 id="挂载阶段：">挂载阶段：<a class="post-anchor" href="#挂载阶段："></a></h2><p><strong>生命周期函数调用顺序：</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">constructor</span>(props){<br>    <span class="hljs-keyword">super</span>(props)<br>}<br><br><span class="hljs-keyword">static</span> getDerivedStateFromProps(props, state)<br><br>render()<br><br>componentDidMount()<br></code></pre></td></tr></tbody></table></figure><h3 id="constructor-NaN">constructor<a class="post-anchor" href="#constructor-NaN"></a></h3><p>组件构造函数，最先被执行，如果没有定义，会被默认生成。要在构造函数中使用 this ,就必须在构造函数第一行执行 super(props)。  </p><p>构造函数作用：</p><ol><li>初始化 state</li><li>给自定义方法绑定 this</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">constructor</span>(props){<br>    <span class="hljs-keyword">super</span>(props)<br>    <span class="hljs-keyword">this</span>.state = {<br>        name: <span class="hljs-string">'kx'</span><br>    }<br>    <span class="hljs-keyword">this</span>.handleClick = <span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>bind(this) 的作用就是保证该自定义方法的 this 始终是指向该组件，可以使用箭头函数代替它。</p><h3 id="getDerivedStateFromProps">getDerivedStateFromProps<a class="post-anchor" href="#getDerivedStateFromProps"></a></h3><ul><li>该方法不常用，只有当 state 的值任何时候都取决于 props 时才会使用  </li><li>静态方法，函数内部不能使用 this  </li><li>接受两个参数，props 和当前的 state</li><li>返回一个对象更新 state 或者 返回 null 不更新</li><li>使用该方法的时候需要初始化 state,否则会报错</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">state = {<br>  name: <span class="hljs-string">'kx'</span><br>}<br><br><span class="hljs-keyword">static</span> getDerivedStateFromProps(props, state) {<br>  <span class="hljs-keyword">if</span> (props.name !== state.name) {<br>    <span class="hljs-keyword">return</span> {<br>      name: props.name<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="render">render<a class="post-anchor" href="#render"></a></h3><ul><li>组件中必须包含 render() 方法。  </li><li>render 是纯函数，只返回需要渲染的东西，不能在其中处理业务逻辑和数据请求。</li><li>return 中必须包含一个 UI 元素。</li></ul><h3 id="componentDidMount">componentDidMount<a class="post-anchor" href="#componentDidMount"></a></h3><p>在组件挂载完成后调用，全局只调用一次，此时可以获取到 DOM 节点并进行操作。<br>通常在该方法内进行异步请求，并可以在异步请求中进行 setState 操作。</p><h2 id="更新阶段">更新阶段<a class="post-anchor" href="#更新阶段"></a></h2><p><strong>生命周期函数调用顺序：</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">getDerivedStateFromProps(props, state)<br><br>shouldComponentUpdate(nextProps, nextState)<br><br>render()<br><br>getSnapshotBeforeUpdate(prevProps, prevState)<br><br>componentDidUpdate(prevProps, prevState, snapshot)<br></code></pre></td></tr></tbody></table></figure><h3 id="getDerivedStateFromProps-1">getDerivedStateFromProps<a class="post-anchor" href="#getDerivedStateFromProps-1"></a></h3><p>与挂载阶段一样</p><h3 id="shouldComponentUpdate">shouldComponentUpdate<a class="post-anchor" href="#shouldComponentUpdate"></a></h3><p>在组件挂载完成后，每次使用 setState 后都会调用该方法。<br>接受两个参数，nextProps 和 nextState，表示新的 props 和 state。<br>返回的是一个布尔值，表示是否需要重新渲染，默认返回 true</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">shouldComponentUpdate(nextProps, nextState) {<br>    <span class="hljs-keyword">return</span> nextState.name !== <span class="hljs-keyword">this</span>.state.name<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="render-1">render<a class="post-anchor" href="#render-1"></a></h3><p>当收到 shouldComponentUpdate 返回的 true 之后，render 会重新渲染</p><h3 id="getSnapshotBeforeUpdate">getSnapshotBeforeUpdate<a class="post-anchor" href="#getSnapshotBeforeUpdate"></a></h3><p>传入两个参数，prevProps 表示更新前的 props，prevState 表示更新前的 state<br>必须有一个返回值，返回值将作为第三个参数传给 componentDidUpdate，如果没有可返回的值，则必须返回 null<br>该方法必须和 componentDidUpdate 一起使用</p><blockquote><p>这个函数的作用是在真实 DOM 更新（componentDidUpdate）前，获取一些需要的信息（类似快照功能），然后作为参数传给 componentDidUpdate。例如:在getSnapShotBeforeUpdate中获取滚动位置，然后作为参数传给componentDidUpdate，就可以直接在渲染真实的 DOM 时就滚动到需要的位置。</p></blockquote><h3 id="componentDidUpdate">componentDidUpdate<a class="post-anchor" href="#componentDidUpdate"></a></h3><p>接受三个参数，之前的 props，之前的 state 以及 getSnapshotBeforeUpdate 返回的值<br>在组件每次更新后都会调用此方法，可以在这个方法内操作 DOM，向服务器发送请求<br>在该方法内使用 setState 时，需要使用 if 语句进行判断，否则将陷入死循环</p><h2 id="卸载阶段">卸载阶段<a class="post-anchor" href="#卸载阶段"></a></h2><h3 id="componentWillUnmount">componentWillUnmount<a class="post-anchor" href="#componentWillUnmount"></a></h3><p>卸载阶段只有这一个生命周期函数，每当React使用完一个组件，这个组件必须从 DOM 中卸载后被销毁，此时 componentWillUnmout 会被执行。<br>可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;../../../images/生命周期.png&quot; data-caption data-fancybox=&quot;images&quot;&gt;&lt;img src=&quot;../../../images/生命周期.png&quot; alt&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
      <category term="React" scheme="http://onekx.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>实现页面上方进度条</title>
    <link href="http://onekx.github.io/post/progress_line/"/>
    <id>http://onekx.github.io/post/progress_line/</id>
    <published>2020-04-05T02:43:47.000Z</published>
    <updated>2020-04-05T04:52:42.911Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p>实现位于页面上方，跟随视图滚动而不断变化的进度条。</p></blockquote><h5 id="1-首先在页面中添加：">1. 首先在页面中添加：<a class="post-anchor" href="#1-首先在页面中添加："></a></h5><figure class="highlight html"><table><tbody><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"progress"</span>></span><br>    <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"line"</span>></span><span class="hljs-symbol">&lt;</span>/div><br><span class="hljs-symbol">&lt;</span>/div><br></code></pre></td></tr></tbody></table></figure><h5 id="2-设置样式：">2. 设置样式：<a class="post-anchor" href="#2-设置样式："></a></h5><figure class="highlight css"><table><tbody><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#progress</span> {<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span><br>    position: fixed<br>    width: <span class="hljs-number">100%</span><br>    height: <span class="hljs-number">0.2rem</span><br>    text-align: left<br>    z-index: <span class="hljs-number">9999</span><br>}<br><br><span class="hljs-selector-id">#progress</span> <span class="hljs-selector-class">.line</span> {<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0%</span><br>    height: <span class="hljs-number">0.2rem</span><br>    background-color: <span class="hljs-number">#0099ff</span><br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="3-编写-JS-代码：">3. 编写 JS 代码：<a class="post-anchor" href="#3-编写-JS-代码："></a></h5><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs JavaScript">$(<span class="hljs-built_in">window</span>).scroll(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>      <span class="hljs-keyword">var</span> pageHeight = <span class="hljs-built_in">document</span>.documentElement.scrollHeight || <span class="hljs-built_in">document</span>.body.scrollHeight <span class="hljs-comment">// 页面总高度</span><br>      <span class="hljs-keyword">var</span> windowHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight || <span class="hljs-built_in">document</span>.body.clientHeight <span class="hljs-comment">// 浏览器视口高度</span><br>      <span class="hljs-keyword">var</span> scrollAvail = pageHeight - windowHeight <span class="hljs-comment">// 可滚动的高度</span><br>      <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop <span class="hljs-comment">// 获取滚动条的高度</span><br>      <span class="hljs-keyword">var</span> ratio = (scrollTop / scrollAvail) * <span class="hljs-number">100</span> + <span class="hljs-string">'%'</span><br>      $(<span class="hljs-string">'#progress > .line'</span>).css(<span class="hljs-string">'width'</span>, ratio)<br>})<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt;实现位于页面上方，跟随视图滚动而不断变化的进度条。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;1-首先在页面中添加：&quot;&gt;1. 首先在页面中添加：&lt;a class=&quot;post-anchor&quot;
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://onekx.github.io/tags/JavaScript/"/>
    
      <category term="CSS" scheme="http://onekx.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>ESLint 的配置</title>
    <link href="http://onekx.github.io/post/deploy_eslint/"/>
    <id>http://onekx.github.io/post/deploy_eslint/</id>
    <published>2020-04-04T07:37:39.000Z</published>
    <updated>2020-04-13T13:16:59.818Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h4 id="1-安装所需要的包">1. 安装所需要的包<a class="post-anchor" href="#1-安装所需要的包"></a></h4>   <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><code class="hljs shell">npm install --save-dev husky lint-staged eslint<br></code></pre></td></tr></tbody></table></figure><h4 id="2-如果配置文件里有使用到airbnb，通过以下命令来安装eslint-config-airbnb及它的相关依赖">2. 如果配置文件里有使用到airbnb，通过以下命令来安装eslint-config-airbnb及它的相关依赖<a class="post-anchor" href="#2-如果配置文件里有使用到airbnb，通过以下命令来安装eslint-config-airbnb及它的相关依赖"></a></h4>   <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><code class="hljs shell">npm install --save-dev eslint-config-airbnb  <br>npm install --save eslint-plugin-import eslint-plugin-react eslint-plugin-jsx-a11y<br></code></pre></td></tr></tbody></table></figure><h4 id="3-设置一个配置文件">3. 设置一个配置文件<a class="post-anchor" href="#3-设置一个配置文件"></a></h4>   <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><code class="hljs shell">./node_modules/.bin/eslint --init<br></code></pre></td></tr></tbody></table></figure><h4 id="4-在根目录下-eslintrc-文件中配置自己的rules，以下是我使用的配置：">4. 在根目录下 .eslintrc 文件中配置自己的rules，以下是我使用的配置：<a class="post-anchor" href="#4-在根目录下-eslintrc-文件中配置自己的rules，以下是我使用的配置："></a></h4>   <figure class="highlight json"><table><tbody><tr><td class="code"><pre><code class="hljs json">{  <br> <span class="hljs-attr">"env"</span>: {  <br>     <span class="hljs-attr">"browser"</span>: <span class="hljs-literal">true</span>,  <br>     <span class="hljs-attr">"es6"</span>: <span class="hljs-literal">true</span>,  <br>     <span class="hljs-attr">"node"</span>: <span class="hljs-literal">true</span>  <br> },  <br> <span class="hljs-attr">"extends"</span>: [  <br>     <span class="hljs-string">"airbnb"</span>  <br> ],  <br> <span class="hljs-attr">"parser"</span>: <span class="hljs-string">"babel-eslint"</span>,  <br> <span class="hljs-attr">"globals"</span>: {  <br>     <span class="hljs-attr">"Atomics"</span>: <span class="hljs-string">"readonly"</span>,  <br>     <span class="hljs-attr">"SharedArrayBuffer"</span>: <span class="hljs-string">"readonly"</span>  <br> },  <br> <span class="hljs-attr">"parserOptions"</span>: {  <br>     <span class="hljs-attr">"ecmaFeatures"</span>: {  <br>         <span class="hljs-attr">"jsx"</span>: <span class="hljs-literal">true</span>,  <br>         <span class="hljs-attr">"legacyDecorators"</span>: <span class="hljs-literal">true</span>  <br>     },  <br>     <span class="hljs-attr">"ecmaVersion"</span>: <span class="hljs-number">2018</span>,  <br>     <span class="hljs-attr">"sourceType"</span>: <span class="hljs-string">"module"</span>  <br> },  <br> <span class="hljs-attr">"plugins"</span>: [  <br>     <span class="hljs-string">"react"</span>  <br> ],  <br> <span class="hljs-attr">"rules"</span>: {  <br>     <span class="hljs-attr">"indent"</span>: [<span class="hljs-string">"error"</span>, <span class="hljs-number">4</span>, { <span class="hljs-attr">"SwitchCase"</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">"flatTernaryExpressions"</span>: <span class="hljs-literal">true</span> }],  <br>     <span class="hljs-attr">"max-len"</span>: [<span class="hljs-string">"error"</span>, { <span class="hljs-attr">"code"</span>: <span class="hljs-number">120</span>, <span class="hljs-attr">"ignoreUrls"</span>: <span class="hljs-literal">true</span> }],  <br>     <span class="hljs-attr">"react/jsx-indent"</span>: [<span class="hljs-string">"error"</span>, <span class="hljs-number">4</span>],  <br>     <span class="hljs-attr">"react/jsx-indent-props"</span>: [<span class="hljs-string">"error"</span>, <span class="hljs-number">4</span>],  <br>     <span class="hljs-attr">"react/jsx-filename-extension"</span>: [<span class="hljs-string">"warn"</span>, { <span class="hljs-attr">"extensions"</span>: [<span class="hljs-string">".js"</span>,<span class="hljs-string">".jsx"</span>] }],  <br>     <span class="hljs-attr">"react/prop-types"</span>: <span class="hljs-string">"off"</span>,  <br>     <span class="hljs-attr">"no-unused-expressions"</span>: [<span class="hljs-string">"error"</span>, { <span class="hljs-attr">"allowShortCircuit"</span>: <span class="hljs-literal">true</span> }],  <br>     <span class="hljs-attr">"no-underscore-dangle"</span>: <span class="hljs-number">0</span>,  <br>     <span class="hljs-attr">"no-console"</span>: [<span class="hljs-string">"error"</span>, { <span class="hljs-attr">"allow"</span>: [<span class="hljs-string">"log"</span>] }],  <br>     <span class="hljs-attr">"react/jsx-props-no-spreading"</span>: [<span class="hljs-string">"error"</span>, { <span class="hljs-attr">"custom"</span>: <span class="hljs-string">"ignore"</span> }],  <br>     <span class="hljs-attr">"import/no-cycle"</span>: <span class="hljs-number">0</span>,  <br>     <span class="hljs-attr">"radix"</span>: [<span class="hljs-string">"error"</span>, <span class="hljs-string">"as-needed"</span>]  <br> }  <br> }<br></code></pre></td></tr></tbody></table></figure><h4 id="5-在-package-json-文件中配置husky和lint-staged，用于提交前的检测，示例：">5. 在 package.json 文件中配置husky和lint-staged，用于提交前的检测，示例：<a class="post-anchor" href="#5-在-package-json-文件中配置husky和lint-staged，用于提交前的检测，示例："></a></h4>   <figure class="highlight"><table><tbody><tr><td class="code"><pre><code class="hljs json">"husky": {  <br>    "hooks": {    <br>        "pre-commit": "lint-staged"  <br>     }<br> },<br> "lint-staged": {  <br>     "*.js": [    <br>         "eslint --fix",    <br>         <span class="hljs-string">"git add"</span>  <br>     ]<br> }<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h4 id=&quot;1-安装所需要的包&quot;&gt;1. 安装所需要的包&lt;a class=&quot;post-anchor&quot; href=&quot;#1-安装所需要的包&quot;&gt;&lt;/a&gt;&lt;/h4&gt;   &lt;figure class=&quot;highlight shell&quot;&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="ESLint" scheme="http://onekx.github.io/tags/ESLint/"/>
    
  </entry>
  
  <entry>
    <title>对 Promise 的理解</title>
    <link href="http://onekx.github.io/post/about_promise/"/>
    <id>http://onekx.github.io/post/about_promise/</id>
    <published>2020-04-02T10:47:31.000Z</published>
    <updated>2020-04-05T03:52:28.651Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><a href="../../../images/Promise.png" data-caption data-fancybox="images"><img src="../../../images/Promise.png" alt></a><hr><p><strong>以下是自己对Promise的简单理解</strong></p><h3 id="Promise的作用：">Promise的作用：<a class="post-anchor" href="#Promise的作用："></a></h3><p>js中使用回调函数进行事件处理，如果嵌套多层回调函数，将会陷入 回调地狱，使代码难以理解以及维护，例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">method1(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>) </span>{<br>    <span class="hljs-keyword">if</span> (err) {<br>        <span class="hljs-keyword">throw</span> err;<br>    } <br>    method2(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>) </span>{<br>        <span class="hljs-keyword">if</span> (err) {<br>            <span class="hljs-keyword">throw</span> err;<br>        } <br>        method3(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>) </span>{<br>            <span class="hljs-keyword">if</span> (err) {<br>                <span class="hljs-keyword">throw</span> err;<br>            } <br>            method4(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>) </span>{<br>                <span class="hljs-keyword">if</span> (err) {<br>                    <span class="hljs-keyword">throw</span> err;<br>                } <br>                method5(result);<br>            });<br>        });<br>    });<br>});<br></code></pre></td></tr></tbody></table></figure><p><strong>Promise就是解决以上这种问题的异步编程方案。</strong></p><hr><h3 id="Promise的构造：">Promise的构造：<a class="post-anchor" href="#Promise的构造："></a></h3><p>直接在控制台中将Promise打印出来:</p><a href="../../../images/Promise的结构.png" data-caption data-fancybox="images"><img src="../../../images/Promise的结构.png" alt></a><p>可以看到 Promise 包含了 resolve, reject, all, race等方法，原型上有 then, catch, finally等方法，所以当 new 一个 Promise 对象时一定包含以上方法。</p><hr><h3 id="Promise的三种状态：">Promise的三种状态：<a class="post-anchor" href="#Promise的三种状态："></a></h3><blockquote><p>Pending（进行中），Fulfilled（已完成），Rejected（已拒绝）</p></blockquote><p>当 Promise 被声明时，即处于 <strong>“Pending”</strong> 状态。<br>接着状态的变更只能是 <strong>“Pending => Fufilled”</strong> （Fufilled对应的就是resolv方法）和 <strong>“Pending => Rejected”</strong>两种，<strong>且状态的变更是单向不可逆的</strong>。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {});<br><span class="hljs-comment">// Pending状态</span><br><span class="hljs-keyword">var</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> resolve());<br><span class="hljs-comment">// Fulfilled状态</span><br><span class="hljs-keyword">var</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> reject());<br><span class="hljs-comment">// Rejected状态</span><br></code></pre></td></tr></tbody></table></figure><hr><h3 id="then-、-catch-和-finally-的用法：">then 、 catch 和 finally 的用法：<a class="post-anchor" href="#then-、-catch-和-finally-的用法："></a></h3><h4 id="then：">then：<a class="post-anchor" href="#then："></a></h4><p>then 为返回成功时调用的方法。<br>then 有两个参数，第一个参数是 resolved 状态的回调函数，第二个参数 <strong>(可选)</strong> 是 rejected 状态的回调函数。</p><blockquote><p>建议 then 中只接受第一个参数，第二个参数放到 catch 中解决</p></blockquote><h4 id="catch：">catch：<a class="post-anchor" href="#catch："></a></h4><p>catch是失败时调用的方法。catch只接受一个参数，即当发生错误时的回调函数。<br><strong>.catch()</strong>  等同于 <strong>.then(null, rejection)</strong> 或 <strong>.then(undefined, rejection)</strong></p><h4 id="finally：">finally：<a class="post-anchor" href="#finally："></a></h4><p>finally方法不管 Promise 对象最后状态如何，在执行完 then 和 catch 指定的回调函数以后，最后都会执行 finally 方法指定的回调函数。</p><p>例：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {<br>    <span class="hljs-keyword">if</span>(flag) {<br>        resolve(<span class="hljs-literal">true</span>);<br>    } <span class="hljs-keyword">else</span> {<br>        reject(<span class="hljs-literal">false</span>);<br>    }<br>});<br><br>promise.then(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功'</span>);<br>}).catch(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败'</span>);<br>}).finally(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'结束'</span>);<br>});<br><br><span class="hljs-comment">// flag = true, 成功 结束。</span><br><span class="hljs-comment">// flag = false 失败 结束。</span><br><span class="hljs-comment">// 都会打印出 “结束”</span><br></code></pre></td></tr></tbody></table></figure><hr><h3 id="all-和-race-方法：">all 和 race 方法：<a class="post-anchor" href="#all-和-race-方法："></a></h3><h4 id="all的用法：">all的用法：<a class="post-anchor" href="#all的用法："></a></h4><p>.all() 接受一个 Promise 的实例数组，只有当所有全部 Promise 执行 resolve 或者有一个 reject 后才执行下面的回调函数。</p><ol><li>当所有 Promise 都为 resolve 时：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {<br>    resolve(<span class="hljs-number">1</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {<br>    resolve(<span class="hljs-number">2</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {<br>    resolve(<span class="hljs-number">3</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise4 = <span class="hljs-built_in">Promise</span>.all([promise1,promise2,promise3]);<br>promise4.then(<span class="hljs-function"><span class="hljs-params">value</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(value);<br>})<br><br><span class="hljs-comment">// [1,2,3]</span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>若某个 Promise 被拒绝了，那么会立即结束，不会等待其他 Promise 的结束：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        reject(<span class="hljs-number">1</span>);<br>    },<span class="hljs-number">1000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        resolve(<span class="hljs-number">2</span>);<br>    },<span class="hljs-number">2000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        resolve(<span class="hljs-number">3</span>);<br>    },<span class="hljs-number">3000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise4 = <span class="hljs-built_in">Promise</span>.all([promise1,promise2,promise3]);<br>promise4.then(<span class="hljs-function"><span class="hljs-params">value</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(value);<br>}).catch(<span class="hljs-function"><span class="hljs-params">value</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(value);<br>})<br>    <br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 因为 promise1 为 reject，所以 .all() 会立即结束，不会等待 promise2 和 promise3</span><br></code></pre></td></tr></tbody></table></figure><h4 id="race-的用法：">race 的用法：<a class="post-anchor" href="#race-的用法："></a></h4><p>race 与 all 一样可以接受一个由 Promise 组成的数组作为参数，但是 race 不会等待所有 Promise 执行完成，只要数组中有一个 Promise 状态发生改变，race 方法就会立即执行回调函数，状态由最先结束的 Promise 决定。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        reject(<span class="hljs-number">1</span>);<br>    },<span class="hljs-number">4000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        resolve(<span class="hljs-number">2</span>);<br>    },<span class="hljs-number">2000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> {<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {<br>        resolve(<span class="hljs-number">3</span>);<br>    },<span class="hljs-number">3000</span>);<br>});<br><br><span class="hljs-keyword">let</span> promise4 = <span class="hljs-built_in">Promise</span>.race([promise1,promise2,promise3]);<br>promise4.then(<span class="hljs-function"><span class="hljs-params">value</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(value);<br>}).catch(<span class="hljs-function"><span class="hljs-params">value</span> =></span> {<br>    <span class="hljs-built_in">console</span>.log(value);<br>})<br><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// promise2 延时两秒最先完成，然后立即结束，状态为resolve</span><br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;../../../images/Promise.png&quot; data-caption data-fancybox=&quot;images&quot;&gt;&lt;img src=&quot;../../../images/Promise.png&quot; al
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://onekx.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://onekx.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
